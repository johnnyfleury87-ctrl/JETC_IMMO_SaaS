schema_name,function_name,arguments,definition;
"auth,email,,""CREATE OR REPLACE FUNCTION auth.email()";
 RETURNS text;
 LANGUAGE sql;
 STABLE;
AS $function$;
  select ;
  coalesce(;
    nullif(current_setting('request.jwt.claim.email', true), ''),;
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email');
  )::text;
$function$;
"
auth,jwt,,CREATE OR REPLACE FUNCTION auth.jwt()";
 RETURNS jsonb;
 LANGUAGE sql;
 STABLE;
AS $function$;
  select ;
    coalesce(;
        nullif(current_setting('request.jwt.claim', true), ''),;
        nullif(current_setting('request.jwt.claims', true), '');
    )::jsonb;
$function$;
"
auth,role,,CREATE OR REPLACE FUNCTION auth.role()";
 RETURNS text;
 LANGUAGE sql;
 STABLE;
AS $function$;
  select ;
  coalesce(;
    nullif(current_setting('request.jwt.claim.role', true), ''),;
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role');
  )::text;
$function$;
"
auth,uid,,CREATE OR REPLACE FUNCTION auth.uid()";
 RETURNS uuid;
 LANGUAGE sql;
 STABLE;
AS $function$;
  select ;
  coalesce(;
    nullif(current_setting('request.jwt.claim.sub', true), ''),;
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub');
  )::uuid;
$function$;
"
extensions,armor,bytea,CREATE OR REPLACE FUNCTION extensions.armor(bytea)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_armor$function$;
"
extensions,armor,bytea, text[], text[]"",""CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_armor$function$;
"
extensions,crypt,text, text"",""CREATE OR REPLACE FUNCTION extensions.crypt(text, text)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_crypt$function$;
"
extensions,dearmor,text,CREATE OR REPLACE FUNCTION extensions.dearmor(text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_dearmor$function$;
"
extensions,decrypt,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_decrypt$function$;
"
extensions,decrypt_iv,bytea, bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$;
"
extensions,digest,text, text"",""CREATE OR REPLACE FUNCTION extensions.digest(text, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_digest$function$;
"
extensions,digest,bytea, text"",""CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_digest$function$;
"
extensions,encrypt,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_encrypt$function$;
"
extensions,encrypt_iv,bytea, bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$;
"
extensions,gen_random_bytes,integer,CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_random_bytes$function$;
"
extensions,gen_random_uuid,,CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()";
 RETURNS uuid;
 LANGUAGE c;
 PARALLEL SAFE;
AS '$libdir/pgcrypto', $function$pg_random_uuid$function$;
"
extensions,gen_salt,text, integer"",""CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)";
 RETURNS text;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$;
"
extensions,gen_salt,text,CREATE OR REPLACE FUNCTION extensions.gen_salt(text)";
 RETURNS text;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_gen_salt$function$;
"
extensions,grant_pg_cron_access,,CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
  IF EXISTS (;
    SELECT;
    FROM pg_event_trigger_ddl_commands() AS ev;
    JOIN pg_extension AS ext;
    ON ev.objid = ext.oid;
    WHERE ext.extname = 'pg_cron';
  );
  THEN;
    grant usage on schema cron to postgres with grant option;
;
    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;
;
    alter default privileges for user supabase_admin in schema cron grant all;
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all;
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all;
        on functions to postgres with grant option;
;
    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$function$;
"
extensions,grant_pg_graphql_access,,CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
    func_is_graphql_resolve bool;
BEGIN;
    func_is_graphql_resolve = (;
        SELECT n.proname = 'resolve';
        FROM pg_event_trigger_ddl_commands() AS ev;
        LEFT JOIN pg_catalog.pg_proc AS n;
        ON ev.objid = n.oid;
    );
;
    IF func_is_graphql_resolve;
    THEN;
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func;
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(;
"            """"operationName"""" text default null,";
            query text default null,;
            variables jsonb default null,;
            extensions jsonb default null;
        );
            returns jsonb;
            language sql;
        as $$;
            select graphql.resolve(;
                query := query,;
                variables := coalesce(variables, '{}'),;
"                """"operationName"""" := """"operationName"""",";
                extensions := extensions;
            );
        $$;
;
        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last;
        -- function in the extension so we need to grant permissions on existing entities AND;
        -- update default permissions to any others that are created after `graphql.resolve`;
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
;
        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles;
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;
;
END;
$function$;
"
extensions,grant_pg_net_access,,CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
  IF EXISTS (;
    SELECT 1;
    FROM pg_event_trigger_ddl_commands() AS ev;
    JOIN pg_extension AS ext;
    ON ev.objid = ext.oid;
    WHERE ext.extname = 'pg_net';
  );
  THEN;
    IF NOT EXISTS (;
      SELECT 1;
      FROM pg_roles;
      WHERE rolname = 'supabase_functions_admin';
    );
    THEN;
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;
;
    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;
;
    IF EXISTS (;
      SELECT FROM pg_extension;
      WHERE extname = 'pg_net';
      -- all versions in use on existing projects as of 2025-02-20;
      -- version 0.12.0 onwards don't need these applied;
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0');
    ) THEN;
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
;
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
;
      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
;
      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$function$;
"
extensions,hmac,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_hmac$function$;
"
extensions,hmac,text, text, text"",""CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pg_hmac$function$;
"
extensions,pg_stat_statements,showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone"",""CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)";
 RETURNS SETOF record;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$;
"
extensions,pg_stat_statements_info,OUT dealloc bigint, OUT stats_reset timestamp with time zone"",""CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)";
 RETURNS record;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$;
"
extensions,pg_stat_statements_reset,userid oid, dbid oid, queryid bigint, minmax_only boolean"",""CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)";
 RETURNS timestamp with time zone;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$;
"
extensions,pgp_armor_headers,text, OUT key text, OUT value text"",""CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)";
 RETURNS SETOF record;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$;
"
extensions,pgp_key_id,bytea,CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$;
"
extensions,pgp_pub_decrypt,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$;
"
extensions,pgp_pub_decrypt,bytea, bytea, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$;
"
extensions,pgp_pub_decrypt,bytea, bytea"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$;
"
extensions,pgp_pub_decrypt_bytea,bytea, bytea"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$;
"
extensions,pgp_pub_decrypt_bytea,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$;
"
extensions,pgp_pub_decrypt_bytea,bytea, bytea, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$;
"
extensions,pgp_pub_encrypt,text, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$;
"
extensions,pgp_pub_encrypt,text, bytea"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$;
"
extensions,pgp_pub_encrypt_bytea,bytea, bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$;
"
extensions,pgp_pub_encrypt_bytea,bytea, bytea"",""CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$;
"
extensions,pgp_sym_decrypt,bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$;
"
extensions,pgp_sym_decrypt,bytea, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)";
 RETURNS text;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$;
"
extensions,pgp_sym_decrypt_bytea,bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$;
"
extensions,pgp_sym_decrypt_bytea,bytea, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$;
"
extensions,pgp_sym_encrypt,text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$;
"
extensions,pgp_sym_encrypt,text, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$;
"
extensions,pgp_sym_encrypt_bytea,bytea, text, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$;
"
extensions,pgp_sym_encrypt_bytea,bytea, text"",""CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)";
 RETURNS bytea;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$;
"
extensions,pgrst_ddl_watch,,CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
  cmd record;
BEGIN;
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands();
  LOOP;
    IF cmd.command_tag IN (;
      'CREATE SCHEMA', 'ALTER SCHEMA';
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE';
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE';
    , 'CREATE VIEW', 'ALTER VIEW';
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW';
    , 'CREATE FUNCTION', 'ALTER FUNCTION';
    , 'CREATE TRIGGER';
    , 'CREATE TYPE', 'ALTER TYPE';
    , 'CREATE RULE';
    , 'COMMENT';
    );
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp;
    AND cmd.schema_name is distinct from 'pg_temp';
    THEN;
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,pgrst_drop_watch,,CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
  obj record;
BEGIN;
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects();
  LOOP;
    IF obj.object_type IN (;
      'schema';
    , 'table';
    , 'foreign table';
    , 'view';
    , 'materialized view';
    , 'function';
    , 'trigger';
    , 'type';
    , 'rule';
    );
    AND obj.is_temporary IS false -- no pg_temp objects;
    THEN;
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$
"
extensions,set_graphql_placeholder,,CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
AS $function$;
    DECLARE;
    graphql_is_dropped bool;
    BEGIN;
    graphql_is_dropped = (;
        SELECT ev.schema_name = 'graphql_public';
        FROM pg_event_trigger_dropped_objects() AS ev;
        WHERE ev.schema_name = 'graphql_public';
    );
;
    IF graphql_is_dropped;
    THEN;
        create or replace function graphql_public.graphql(;
"            """"operationName"""" text default null,";
            query text default null,;
            variables jsonb default null,;
            extensions jsonb default null;
        );
            returns jsonb;
            language plpgsql;
        as $$;
            DECLARE;
                server_version float;
            BEGIN;
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);
;
                IF server_version >= 14 THEN;
                    RETURN jsonb_build_object(;
                        'errors', jsonb_build_array(;
                            jsonb_build_object(;
                                'message', 'pg_graphql extension is not enabled.';
                            );
                        );
                    );
                ELSE;
                    RETURN jsonb_build_object(;
                        'errors', jsonb_build_array(;
                            jsonb_build_object(;
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.';
                            );
                        );
                    );
                END IF;
            END;
        $$;
    END IF;
;
    END;
$function$;
"
extensions,uuid_generate_v1,,CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()";
 RETURNS uuid;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$;
"
extensions,uuid_generate_v1mc,,CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()";
 RETURNS uuid;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$;
"
extensions,uuid_generate_v3,namespace uuid, name text"",""CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$;
"
extensions,uuid_generate_v4,,CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()";
 RETURNS uuid;
 LANGUAGE c;
 PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$;
"
extensions,uuid_generate_v5,namespace uuid, name text"",""CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$;
"
extensions,uuid_nil,,CREATE OR REPLACE FUNCTION extensions.uuid_nil()";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_nil$function$;
"
extensions,uuid_ns_dns,,CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$;
"
extensions,uuid_ns_oid,,CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$;
"
extensions,uuid_ns_url,,CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$;
"
extensions,uuid_ns_x500,,CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()";
 RETURNS uuid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$;
"
graphql,_internal_resolve,query text, variables jsonb, """"operationName"""" text, extensions jsonb"",""CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, """"operationName"""" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)";
 RETURNS jsonb;
 LANGUAGE c;
AS '$libdir/pg_graphql', $function$resolve_wrapper$function$;
"
graphql,comment_directive,comment_ text,CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)";
 RETURNS jsonb;
 LANGUAGE sql;
 IMMUTABLE;
AS $function$;
    /*;
    comment on column public.account.name is '@graphql.name: myField';
    */;
    select;
        coalesce(;
            (;
                regexp_match(;
                    comment_,;
                    '@graphql\((.+)\)';
                );
            )[1]::jsonb,;
            jsonb_build_object();
        );
$function$;
"
graphql,exception,message text,CREATE OR REPLACE FUNCTION graphql.exception(message text)";
 RETURNS text;
 LANGUAGE plpgsql;
AS $function$;
begin;
    raise exception using errcode='22000', message=message;
end;
$function$;
"
graphql,get_schema_version,,CREATE OR REPLACE FUNCTION graphql.get_schema_version()";
 RETURNS integer;
 LANGUAGE sql;
 SECURITY DEFINER;
AS $function$;
    select last_value from graphql.seq_schema_version;
$function$;
"
graphql,increment_schema_version,,CREATE OR REPLACE FUNCTION graphql.increment_schema_version()";
 RETURNS event_trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
begin;
    perform pg_catalog.nextval('graphql.seq_schema_version');
end;
$function$;
"
graphql,resolve,query text, variables jsonb, """"operationName"""" text, extensions jsonb"",""CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, """"operationName"""" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
AS $function$;
declare;
    res jsonb;
    message_text text;
begin;
  begin;
"    select graphql._internal_resolve(""""query"""" := """"query"""",";
"                                     """"variables"""" := """"variables"""",";
"                                     """"operationName"""" := """"operationName"""",";
"                                     """"extensions"""" := """"extensions"""") into res";
    return res;
  exception;
    when others then;
    get stacked diagnostics message_text = message_text;
    return;
    jsonb_build_object('data', null,;
                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));
  end;
end;
$function$;
"
graphql_public,graphql,""operationName"""" text, query text, variables jsonb, extensions jsonb"",""CREATE OR REPLACE FUNCTION graphql_public.graphql(""""operationName"""" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)";
 RETURNS jsonb;
 LANGUAGE sql;
AS $function$;
            select graphql.resolve(;
                query := query,;
                variables := coalesce(variables, '{}'),;
"                """"operationName"""" := """"operationName"""",";
                extensions := extensions;
            );
        $function$;
"
pgbouncer,get_auth,p_usename text,CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)";
 RETURNS TABLE(username text, password text);
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO '';
AS $function$;
  BEGIN;
      RAISE DEBUG 'PgBouncer auth request: %', p_usename;
;
      RETURN QUERY;
      SELECT;
          rolname::text,;
          CASE WHEN rolvaliduntil < now();
              THEN null;
              ELSE rolpassword::text;
          END;
      FROM pg_authid;
      WHERE rolname=$1 and rolcanlogin;
  END;
  $function$;
"
public,accept_ticket_and_create_mission,p_ticket_id uuid, p_entreprise_id uuid"",""CREATE OR REPLACE FUNCTION public.accept_ticket_and_create_mission(p_ticket_id uuid, p_entreprise_id uuid)";
 RETURNS uuid;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_mission_id uuid;
  v_ticket_statut ticket_status;
  v_mode_diffusion text;
  v_entreprise_assignee uuid;
  v_locked_at timestamptz;
  v_regie_id uuid;
BEGIN;
  -- Récupérer infos ticket;
  SELECT statut, mode_diffusion, entreprise_id, locked_at, regie_id ;
  INTO v_ticket_statut, v_mode_diffusion, v_entreprise_assignee, v_locked_at, v_regie_id;
  FROM tickets ;
  WHERE id = p_ticket_id;
  ;
  IF NOT FOUND THEN ;
    RAISE EXCEPTION 'Ticket % non trouvé', p_ticket_id; 
  END IF;
;
  -- Vérifier que ticket est au statut 'en_attente';
  IF v_ticket_statut != 'en_attente' THEN;
    RAISE EXCEPTION 'Ticket doit être au statut en_attente (statut actuel: %)', v_ticket_statut;
  END IF;
;
  -- Vérifier que ticket n'est pas déjà verrouillé (accepté par autre entreprise);
  IF v_locked_at IS NOT NULL THEN;
    RAISE EXCEPTION 'Ticket déjà verrouillé (accepté par une autre entreprise)';
  END IF;
;
  -- Validation selon mode diffusion;
  IF v_mode_diffusion = 'public' THEN;
    -- Mode public: Vérifier que entreprise est autorisée en mode 'general';
    IF NOT EXISTS (;
      SELECT 1 FROM regies_entreprises ;
      WHERE regie_id = v_regie_id ;
      AND entreprise_id = p_entreprise_id ;
      AND mode_diffusion = 'general';
    ) THEN;
      RAISE EXCEPTION 'Entreprise % non autorisée pour tickets publics de régie %', p_entreprise_id, v_regie_id;
    END IF;
    ;
  ELSIF v_mode_diffusion = 'assigné' THEN;
    -- Mode assigné: Vérifier que entreprise correspond à celle assignée;
    IF v_entreprise_assignee IS NULL THEN;
      RAISE EXCEPTION 'Ticket en mode assigné mais aucune entreprise assignée (données incohérentes)';
    END IF;
    IF v_entreprise_assignee != p_entreprise_id THEN;
      RAISE EXCEPTION 'Ticket assigné à une autre entreprise (assignée: %, tentée: %)', v_entreprise_assignee, p_entreprise_id;
    END IF;
    ;
  ELSE;
    RAISE EXCEPTION 'Mode diffusion invalide ou NULL: %', COALESCE(v_mode_diffusion, 'NULL');
  END IF;
;
  -- Verrouiller ticket (locked_at + entreprise_id si pas déjà rempli en mode assigné);
  UPDATE tickets ;
  SET locked_at = now(),;
      entreprise_id = p_entreprise_id,;
      updated_at = now();
  WHERE id = p_ticket_id;
;
  -- Changer statut en_attente → en_cours via RPC;
  PERFORM update_ticket_statut(p_ticket_id, 'en_cours');
;
  -- Créer mission (contrainte UNIQUE sur ticket_id empêche doublons);
  INSERT INTO missions (;
    id,;
    ticket_id, ;
    entreprise_id, ;
    statut,;
    created_at,;
    updated_at;
  ) VALUES (;
    gen_random_uuid(),;
    p_ticket_id,;
    p_entreprise_id,;
    'en_attente',;
    now(),;
    now();
  ) RETURNING id INTO v_mission_id;
;
  RETURN v_mission_id;
END;
$function$;
"
public,assign_technicien_to_mission,p_mission_id uuid, p_technicien_id uuid, p_date_intervention_prevue timestamp with time zone"",""CREATE OR REPLACE FUNCTION public.assign_technicien_to_mission(p_mission_id uuid, p_technicien_id uuid, p_date_intervention_prevue timestamp with time zone DEFAULT NULL::timestamp with time zone)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_mission_entreprise_id uuid;
  v_technicien_entreprise_id uuid;
begin;
  -- 1. Vérifier que la mission existe et récupérer son entreprise;
  select entreprise_id into v_mission_entreprise_id;
  from missions;
  where id = p_mission_id;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission non trouvée';
    );
  end if;
  ;
  -- 2. Vérifier que le technicien existe et récupérer son entreprise;
  select entreprise_id into v_technicien_entreprise_id;
  from techniciens;
  where id = p_technicien_id;
  and actif = true;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Technicien non trouvé ou inactif';
    );
  end if;
  ;
  -- 3. Vérifier que le technicien appartient à la même entreprise;
  if v_mission_entreprise_id != v_technicien_entreprise_id then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Le technicien n''appartient pas à l''entreprise de la mission';
    );
  end if;
  ;
  -- 4. Assigner le technicien à la mission;
  update missions;
  set ;
    technicien_id = p_technicien_id,;
    date_intervention_prevue = coalesce(p_date_intervention_prevue, date_intervention_prevue);
  where id = p_mission_id;
  ;
  return jsonb_build_object(;
    'success', true;
  );
end;
$function$;
"
public,cancel_facture,p_facture_id uuid, p_raison text"",""CREATE OR REPLACE FUNCTION public.cancel_facture(p_facture_id uuid, p_raison text DEFAULT NULL::text)";
 RETURNS factures;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_facture factures;
begin;
  -- Récupérer la facture;
  select * into v_facture from factures where id = p_facture_id;
  ;
  if not found then;
    raise exception 'Facture non trouvée';
  end if;
  ;
  -- Vérifier qu'elle n'est pas payée;
  if v_facture.statut = 'payee' then;
    raise exception 'Impossible d''annuler une facture déjà payée';
  end if;
  ;
  if v_facture.statut = 'annulee' then;
    raise exception 'Facture déjà annulée';
  end if;
  ;
  -- Annuler la facture;
  update factures;
  set statut = 'annulee',;
      notes = coalesce(notes || E'\n\nAnnulation: ' || p_raison, 'Annulation: ' || p_raison);
  where id = p_facture_id;
  returning * into v_facture;
  ;
  return v_facture;
end;
$function$;
"
public,cancel_mission,p_mission_id uuid, p_raison text"",""CREATE OR REPLACE FUNCTION public.cancel_mission(p_mission_id uuid, p_raison text DEFAULT NULL::text)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_statut text;
begin;
  -- 1. Vérifier que la mission existe;
  select statut into v_current_statut;
  from missions;
  where id = p_mission_id;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission non trouvée';
    );
  end if;
  ;
  -- 2. Vérifier que la mission n'est pas déjà validee;
  if v_current_statut = 'validee' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Une mission validée ne peut pas être annulée';
    );
  end if;
  ;
  -- 3. Annuler la mission;
  update missions;
  set ;
    statut = 'annulee',;
    notes = coalesce(notes || E'\n\nRaison annulation: ' || p_raison, 'Raison: ' || p_raison);
  where id = p_mission_id;
  ;
  -- 4. Déverrouiller le ticket (pour permettre une nouvelle mission);
  update tickets;
  set locked_at = null;
  where id = (select ticket_id from missions where id = p_mission_id);
  ;
  return jsonb_build_object(;
    'success', true;
  );
end;
$function$;
"
public,cash_dist,money, money"",""CREATE OR REPLACE FUNCTION public.cash_dist(money, money)";
 RETURNS money;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$cash_dist$function$;
"
public,change_plan,p_abonnement_id uuid, p_nouveau_plan_id uuid, p_prorata boolean"",""CREATE OR REPLACE FUNCTION public.change_plan(p_abonnement_id uuid, p_nouveau_plan_id uuid, p_prorata boolean DEFAULT true)";
 RETURNS uuid;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_ancien_abonnement RECORD;
    v_nouveau_plan RECORD;
    v_nouveau_abonnement_id UUID;
    v_jours_restants INTEGER;
    v_nouvelle_date_fin DATE;
BEGIN;
    -- Récupérer l'ancien abonnement;
    SELECT * INTO v_ancien_abonnement;
    FROM public.abonnements;
    WHERE id = p_abonnement_id;
    AND statut = 'actif';
    ;
    IF NOT FOUND THEN;
        RAISE EXCEPTION 'Abonnement introuvable ou inactif';
    END IF;
    ;
    -- Récupérer le nouveau plan;
    SELECT * INTO v_nouveau_plan;
    FROM public.plans;
    WHERE id = p_nouveau_plan_id;
    AND actif = true;
    ;
    IF NOT FOUND THEN;
        RAISE EXCEPTION 'Nouveau plan introuvable ou inactif';
    END IF;
    ;
    -- Calculer la nouvelle date de fin;
    v_jours_restants := v_ancien_abonnement.date_fin - CURRENT_DATE;
    IF v_jours_restants < 0 THEN;
        v_jours_restants := 0;
    END IF;
    ;
    IF v_ancien_abonnement.type_periode = 'mensuel' THEN;
        v_nouvelle_date_fin := CURRENT_DATE + INTERVAL '1 month';
    ELSE;
        v_nouvelle_date_fin := CURRENT_DATE + INTERVAL '1 year';
    END IF;
    ;
    -- Annuler l'ancien abonnement;
    UPDATE public.abonnements;
    SET statut = 'annule',;
        updated_at = now();
    WHERE id = p_abonnement_id;
    ;
    -- Créer le nouvel abonnement;
    INSERT INTO public.abonnements (;
        entreprise_id,;
        regie_id,;
        plan_id,;
        type_periode,;
        date_debut,;
        date_fin,;
        statut,;
        montant_paye,;
        date_prochain_paiement,;
        missions_ce_mois,;
        dernier_reset_quota;
    ) VALUES (;
        v_ancien_abonnement.entreprise_id,;
        v_ancien_abonnement.regie_id,;
        p_nouveau_plan_id,;
        v_ancien_abonnement.type_periode,;
        CURRENT_DATE,;
        v_nouvelle_date_fin,;
        'actif',;
        CASE ;
            WHEN v_ancien_abonnement.type_periode = 'mensuel' ;
            THEN v_nouveau_plan.prix_mensuel;
            ELSE v_nouveau_plan.prix_annuel;
        END,;
        v_nouvelle_date_fin,;
        v_ancien_abonnement.missions_ce_mois, -- Conserver le compteur;
        v_ancien_abonnement.dernier_reset_quota;
    );
    RETURNING id INTO v_nouveau_abonnement_id;
    ;
    RETURN v_nouveau_abonnement_id;
END;
$function$;
"
public,check_access_module,p_module_name character varying, p_entreprise_id uuid, p_regie_id uuid"",""CREATE OR REPLACE FUNCTION public.check_access_module(p_module_name character varying, p_entreprise_id uuid DEFAULT NULL::uuid, p_regie_id uuid DEFAULT NULL::uuid)";
 RETURNS boolean;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_modules_actifs JSONB;
    v_statut VARCHAR;
BEGIN;
    -- Récupérer le plan actuel;
    SELECT ;
        p.modules_actifs,;
        a.statut;
    INTO v_modules_actifs, v_statut;
    FROM public.abonnements a;
    JOIN public.plans p ON a.plan_id = p.id;
    WHERE ;
        (p_entreprise_id IS NOT NULL AND a.entreprise_id = p_entreprise_id) OR;
        (p_regie_id IS NOT NULL AND a.regie_id = p_regie_id);
    AND a.statut = 'actif';
    ORDER BY a.created_at DESC;
    LIMIT 1;
    ;
    -- Si pas d'abonnement actif;
    IF NOT FOUND OR v_statut != 'actif' THEN;
        RETURN false;
    END IF;
    ;
    -- Vérifier si module dans la liste;
    RETURN v_modules_actifs ? p_module_name;
END;
$function$;
"
public,check_disponibilites_before_diffusion,,CREATE OR REPLACE FUNCTION public.check_disponibilites_before_diffusion()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_count_disponibilites integer;
BEGIN;
  -- Vérifier uniquement si transition vers statut 'en_attente' (diffusion);
  IF NEW.statut = 'en_attente' AND (OLD.statut IS NULL OR OLD.statut != 'en_attente') THEN;
    ;
    -- Compter créneaux disponibilité existants;
    SELECT COUNT(*) INTO v_count_disponibilites;
    FROM tickets_disponibilites;
    WHERE ticket_id = NEW.id;
    ;
    -- Vérifier exactement 3 créneaux;
    IF v_count_disponibilites != 3 THEN;
      RAISE EXCEPTION 'Un ticket doit avoir exactement 3 disponibilités avant diffusion (actuellement : %)', v_count_disponibilites;
    END IF;
  END IF;
  ;
  RETURN NEW;
END;
$function$;
"
public,check_locataire_has_logement_for_ticket,,CREATE OR REPLACE FUNCTION public.check_locataire_has_logement_for_ticket()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_logement_id uuid;
BEGIN;
  -- Récupérer logement_id du locataire;
  SELECT logement_id INTO v_logement_id;
  FROM locataires;
  WHERE id = NEW.locataire_id;
;
  -- Vérifier que le locataire a un logement;
  IF v_logement_id IS NULL THEN;
    RAISE EXCEPTION 'RÈGLE MÉTIER VIOLÉE : Le locataire % doit avoir un logement assigné pour créer un ticket. Demandez à votre régie de vous attribuer un logement.', NEW.locataire_id;
      USING HINT = 'Contactez votre régie pour être rattaché à un logement avant de créer un ticket';
  END IF;
;
  RETURN NEW;
END;
$function$;
"
public,check_quota,p_quota_type character varying, p_entreprise_id uuid, p_regie_id uuid"",""CREATE OR REPLACE FUNCTION public.check_quota(p_quota_type character varying, p_entreprise_id uuid DEFAULT NULL::uuid, p_regie_id uuid DEFAULT NULL::uuid)";
 RETURNS TABLE(quota_atteint boolean, limite integer, utilisation integer);
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_plan RECORD;
    v_abonnement RECORD;
    v_utilisation INTEGER;
BEGIN;
    -- Récupérer le plan et l'abonnement;
    SELECT ;
        a.id as abonnement_id,;
        a.missions_ce_mois,;
        a.dernier_reset_quota,;
        p.limite_missions_mois,;
        p.limite_techniciens,;
        p.limite_utilisateurs;
    INTO v_abonnement;
    FROM public.abonnements a;
    JOIN public.plans p ON a.plan_id = p.id;
    WHERE ;
        (p_entreprise_id IS NOT NULL AND a.entreprise_id = p_entreprise_id) OR;
        (p_regie_id IS NOT NULL AND a.regie_id = p_regie_id);
    AND a.statut = 'actif';
    ORDER BY a.created_at DESC;
    LIMIT 1;
    ;
    -- Si pas d'abonnement;
    IF NOT FOUND THEN;
        RETURN QUERY SELECT true, 0, 0;
        RETURN;
    END IF;
    ;
    -- Missions;
    IF p_quota_type = 'missions' THEN;
        -- Reset quota si nouveau mois;
        IF v_abonnement.dernier_reset_quota < DATE_TRUNC('month', CURRENT_DATE)::DATE THEN;
            UPDATE public.abonnements ;
            SET missions_ce_mois = 0, dernier_reset_quota = CURRENT_DATE;
            WHERE id = v_abonnement.abonnement_id;
            v_utilisation := 0;
        ELSE;
            v_utilisation := v_abonnement.missions_ce_mois;
        END IF;
        ;
        -- NULL = illimité;
        IF v_abonnement.limite_missions_mois IS NULL THEN;
            RETURN QUERY SELECT false, NULL::INTEGER, v_utilisation;
        ELSE;
            RETURN QUERY SELECT ;
                v_utilisation >= v_abonnement.limite_missions_mois,;
                v_abonnement.limite_missions_mois,;
                v_utilisation;
        END IF;
        RETURN;
    END IF;
    ;
    -- Techniciens;
    IF p_quota_type = 'techniciens' THEN;
        SELECT COUNT(*) INTO v_utilisation;
        FROM public.techniciens;
        WHERE (p_entreprise_id IS NOT NULL AND entreprise_id = p_entreprise_id);
        ;
        IF v_abonnement.limite_techniciens IS NULL THEN;
            RETURN QUERY SELECT false, NULL::INTEGER, v_utilisation;
        ELSE;
            RETURN QUERY SELECT ;
                v_utilisation >= v_abonnement.limite_techniciens,;
                v_abonnement.limite_techniciens,;
                v_utilisation;
        END IF;
        RETURN;
    END IF;
    ;
    -- Utilisateurs;
    IF p_quota_type = 'utilisateurs' THEN;
        IF p_entreprise_id IS NOT NULL THEN;
            SELECT COUNT(*) INTO v_utilisation;
            FROM profiles;
            WHERE entreprise_id = p_entreprise_id;
        ELSIF p_regie_id IS NOT NULL THEN;
            SELECT COUNT(*) INTO v_utilisation;
            FROM profiles;
            WHERE regie_id = p_regie_id;
        END IF;
        ;
        IF v_abonnement.limite_utilisateurs IS NULL THEN;
            RETURN QUERY SELECT false, NULL::INTEGER, v_utilisation;
        ELSE;
            RETURN QUERY SELECT ;
                v_utilisation >= v_abonnement.limite_utilisateurs,;
                v_abonnement.limite_utilisateurs,;
                v_utilisation;
        END IF;
        RETURN;
    END IF;
    ;
    -- Type inconnu;
    RAISE EXCEPTION 'Type de quota invalide: %', p_quota_type;
END;
$function$;
"
public,complete_mission,p_mission_id uuid, p_rapport_url text"",""CREATE OR REPLACE FUNCTION public.complete_mission(p_mission_id uuid, p_rapport_url text DEFAULT NULL::text)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_statut text;
  v_technicien_id uuid;
begin;
  -- 1. Vérifier que la mission existe;
  select statut, technicien_id ;
  into v_current_statut, v_technicien_id;
  from missions;
  where id = p_mission_id;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission non trouvée';
    );
  end if;
  ;
  -- 2. Vérifier que la mission est en_cours;
  if v_current_statut != 'en_cours' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'La mission doit être en_cours pour être terminée (statut actuel: ' || v_current_statut || ')';
    );
  end if;
  ;
  -- 3. Vérifier qu'un technicien est assigné;
  if v_technicien_id is null then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'La mission doit avoir un technicien assigné';
    );
  end if;
  ;
  -- 4. Terminer la mission;
  update missions;
  set ;
    statut = 'terminee',;
    completed_at = now(),;
    date_intervention_realisee = now(),;
    rapport_url = coalesce(p_rapport_url, rapport_url);
  where id = p_mission_id;
  ;
  return jsonb_build_object(;
    'success', true;
  );
end;
$function$;
"
public,create_abonnement,p_plan_id uuid, p_entreprise_id uuid, p_regie_id uuid, p_type_periode character varying"",""CREATE OR REPLACE FUNCTION public.create_abonnement(p_plan_id uuid, p_entreprise_id uuid DEFAULT NULL::uuid, p_regie_id uuid DEFAULT NULL::uuid, p_type_periode character varying DEFAULT 'mensuel'::character varying)";
 RETURNS uuid;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_plan RECORD;
    v_date_fin DATE;
    v_montant DECIMAL(10, 2);
    v_abonnement_id UUID;
BEGIN;
    -- Vérifier que plan existe;
    SELECT * INTO v_plan FROM public.plans WHERE id = p_plan_id AND actif = true;
    IF NOT FOUND THEN;
        RAISE EXCEPTION 'Plan introuvable ou inactif';
    END IF;
    ;
    -- Vérifier qu'un seul client est fourni;
    IF (p_entreprise_id IS NULL AND p_regie_id IS NULL) OR ;
       (p_entreprise_id IS NOT NULL AND p_regie_id IS NOT NULL) THEN;
        RAISE EXCEPTION 'Fournir entreprise_id OU regie_id (pas les deux)';
    END IF;
    ;
    -- Calculer date de fin et montant;
    IF p_type_periode = 'mensuel' THEN;
        v_date_fin := CURRENT_DATE + INTERVAL '1 month';
        v_montant := v_plan.prix_mensuel;
    ELSIF p_type_periode = 'annuel' THEN;
        v_date_fin := CURRENT_DATE + INTERVAL '1 year';
        v_montant := v_plan.prix_annuel;
    ELSE;
        RAISE EXCEPTION 'Type de période invalide (mensuel ou annuel)';
    END IF;
    ;
    -- Créer l'abonnement;
    INSERT INTO public.abonnements (;
        entreprise_id,;
        regie_id,;
        plan_id,;
        type_periode,;
        date_debut,;
        date_fin,;
        statut,;
        montant_paye,;
        date_prochain_paiement;
    ) VALUES (;
        p_entreprise_id,;
        p_regie_id,;
        p_plan_id,;
        p_type_periode,;
        CURRENT_DATE,;
        v_date_fin,;
        'actif',;
        v_montant,;
        v_date_fin;
    );
    RETURNING id INTO v_abonnement_id;
    ;
    RETURN v_abonnement_id;
END;
$function$;
"
public,create_system_message,p_mission_id uuid, p_content text"",""CREATE OR REPLACE FUNCTION public.create_system_message(p_mission_id uuid, p_content text)";
 RETURNS messages;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_message messages;
begin;
  insert into messages (;
    mission_id,;
    sender_user_id,;
    sender_name,;
    sender_role,;
    content,;
    type;
  );
  values (;
    p_mission_id,;
    (select id from profiles where role = 'admin_jtec' limit 1),  -- Système;
    'Système',;
    'system',;
    p_content,;
    'system';
  );
  returning * into v_message;
  ;
  return v_message;
end;
$function$;
"
public,creer_locataire_complet,p_nom text, p_prenom text, p_email text, p_profile_id uuid, p_regie_id uuid, p_logement_id uuid, p_date_entree date, p_telephone text, p_date_naissance date, p_contact_urgence_nom text, p_contact_urgence_telephone text"",""CREATE OR REPLACE FUNCTION public.creer_locataire_complet(p_nom text, p_prenom text, p_email text, p_profile_id uuid, p_regie_id uuid, p_logement_id uuid DEFAULT NULL::uuid, p_date_entree date DEFAULT NULL::date, p_telephone text DEFAULT NULL::text, p_date_naissance date DEFAULT NULL::date, p_contact_urgence_nom text DEFAULT NULL::text, p_contact_urgence_telephone text DEFAULT NULL::text)";
 RETURNS json;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
  v_locataire_id uuid;
  v_logement_regie_id uuid;
BEGIN;
  -- garde-fou;
  IF p_regie_id IS NULL THEN;
    RAISE EXCEPTION 'p_regie_id is required';
  END IF;
;
  -- si logement fourni, vérifier qu'il appartient à la régie;
  IF p_logement_id IS NOT NULL THEN;
    SELECT l.regie_id INTO v_logement_regie_id;
    FROM public.logements l;
    WHERE l.id = p_logement_id;
;
    IF v_logement_regie_id IS NULL THEN;
      RAISE EXCEPTION 'Logement introuvable: %', p_logement_id;
    END IF;
;
    IF v_logement_regie_id <> p_regie_id THEN;
      RAISE EXCEPTION 'Logement % n''appartient pas à la régie %', p_logement_id, p_regie_id;
    END IF;
  END IF;
;
  -- insertion locataire;
  INSERT INTO public.locataires (;
    nom,;
    prenom,;
    email,;
    profile_id,;
    regie_id,;
    logement_id,;
    date_entree,;
    telephone,;
    date_naissance,;
    contact_urgence_nom,;
    contact_urgence_telephone;
  );
  VALUES (;
    p_nom,;
    p_prenom,;
    p_email,;
    p_profile_id,;
    p_regie_id,;
    p_logement_id,;
    p_date_entree,;
    p_telephone,;
    p_date_naissance,;
    p_contact_urgence_nom,;
    p_contact_urgence_telephone;
  );
  RETURNING id INTO v_locataire_id;
;
"  -- si logement fourni, passer en """"occupé""""";
  IF p_logement_id IS NOT NULL THEN;
    UPDATE public.logements;
    SET statut = 'occupé';
    WHERE id = p_logement_id;
  END IF;
;
  RETURN json_build_object(;
    'success', true,;
    'locataire_id', v_locataire_id,;
    'logement_id', p_logement_id;
  );
END;
$function$;
"
public,creer_locataire_complet,p_nom text, p_prenom text, p_email text, p_profile_id uuid, p_logement_id uuid, p_date_entree date, p_telephone text, p_date_naissance date, p_contact_urgence_nom text, p_contact_urgence_telephone text"",""CREATE OR REPLACE FUNCTION public.creer_locataire_complet(p_nom text, p_prenom text, p_email text, p_profile_id uuid, p_logement_id uuid DEFAULT NULL::uuid, p_date_entree date DEFAULT NULL::date, p_telephone text DEFAULT NULL::text, p_date_naissance date DEFAULT NULL::date, p_contact_urgence_nom text DEFAULT NULL::text, p_contact_urgence_telephone text DEFAULT NULL::text)";
 RETURNS json;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_locataire_id uuid;
  v_regie_id uuid;
  v_logement_numero text;
  v_immeuble_nom text;
BEGIN;
  -- ========================================;
  -- 1. Vérifier que logement existe et récupérer info (UNIQUEMENT SI logement_id fourni);
  -- ========================================;
  IF p_logement_id IS NOT NULL THEN;
    SELECT ;
      i.regie_id,;
      l.numero,;
      im.nom;
    INTO v_regie_id, v_logement_numero, v_immeuble_nom;
    FROM logements l;
    JOIN immeubles im ON im.id = l.immeuble_id;
    JOIN regies r ON r.id = im.regie_id;
    JOIN profiles p ON p.id = r.profile_id;
    WHERE l.id = p_logement_id;
      AND p.id = auth.uid();  -- Vérifier que l'utilisateur connecté est la régie propriétaire
    ;
    IF NOT FOUND THEN;
      RAISE EXCEPTION 'Logement non trouvé ou vous n''avez pas les droits sur ce logement';
    END IF;
    ;
    -- ========================================;
    -- 4. Vérifier que logement n'a pas déjà un locataire actif;
    -- ========================================;
    IF EXISTS (;
      SELECT 1 ;
      FROM locataires ;
      WHERE logement_id = p_logement_id;
        AND date_sortie IS NULL  -- Locataire actuel (pas encore sorti);
    ) THEN;
      RAISE EXCEPTION 'Ce logement a déjà un locataire actif. Veuillez d''abord clôturer le locataire actuel (date_sortie).';
    END IF;
  END IF;
  ;
  -- ========================================;
  -- 2. Vérifier que profile_id existe et role='locataire';
  -- ========================================;
  IF NOT EXISTS (;
    SELECT 1 ;
    FROM profiles ;
    WHERE id = p_profile_id ;
      AND role = 'locataire';
  ) THEN;
    RAISE EXCEPTION 'Profile non trouvé ou rôle incorrect (doit être ''locataire'')';
  END IF;
  ;
  -- ========================================;
  -- 3. Vérifier que profile_id n'est pas déjà utilisé;
  -- ========================================;
  IF EXISTS (;
    SELECT 1 ;
    FROM locataires ;
    WHERE profile_id = p_profile_id;
  ) THEN;
    RAISE EXCEPTION 'Ce profile est déjà associé à un locataire existant';
  END IF;
  ;
  -- ========================================;
  -- 5. Créer locataire;
  -- ========================================;
  INSERT INTO locataires (;
    nom,;
    prenom,;
    email,;
    profile_id,;
    logement_id,;
    date_entree,;
    telephone,;
    date_naissance,;
    contact_urgence_nom,;
    contact_urgence_telephone;
  );
  VALUES (;
    p_nom,;
    p_prenom,;
    p_email,;
    p_profile_id,;
    p_logement_id,;
    p_date_entree,;
    p_telephone,;
    p_date_naissance,;
    p_contact_urgence_nom,;
    p_contact_urgence_telephone;
  );
  RETURNING id INTO v_locataire_id;
  ;
  -- ========================================;
  -- 6. Optionnel : Mettre à jour statut logement (UNIQUEMENT si logement_id fourni);
  -- ========================================;
  IF p_logement_id IS NOT NULL THEN;
    UPDATE logements;
    SET statut = 'occupé';
    WHERE id = p_logement_id;
  END IF;
  ;
  -- ========================================;
  -- 7. Retourner résultat;
  -- ========================================;
  RETURN json_build_object(;
    'success', true,;
    'locataire_id', v_locataire_id,;
    'profile_id', p_profile_id,;
    'email', p_email,;
    'logement', CASE ;
      WHEN p_logement_id IS NOT NULL THEN json_build_object(;
        'id', p_logement_id,;
        'numero', v_logement_numero,;
        'immeuble', v_immeuble_nom;
      );
      ELSE NULL;
    END,;
    'message', 'Locataire créé avec succès';
  );
  ;
EXCEPTION;
  WHEN OTHERS THEN;
    -- Rollback automatique en cas d'erreur;
    RAISE EXCEPTION 'Erreur création locataire : %', SQLERRM;
END;
$function$;
"
public,date_dist,date, date"",""CREATE OR REPLACE FUNCTION public.date_dist(date, date)";
 RETURNS integer;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$date_dist$function$;
"
public,diffuser_ticket,p_ticket_id uuid, p_mode_diffusion text, p_entreprise_id uuid"",""CREATE OR REPLACE FUNCTION public.diffuser_ticket(p_ticket_id uuid, p_mode_diffusion text, p_entreprise_id uuid DEFAULT NULL::uuid)";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_statut_actuel ticket_status;
  v_regie_id uuid;
BEGIN;
  -- Vérifier que l'utilisateur est bien associé à une régie;
  SELECT get_user_regie_id() INTO v_regie_id;
  IF v_regie_id IS NULL THEN;
    RAISE EXCEPTION 'Utilisateur non associé à une régie';
  END IF;
;
  -- Récupérer statut actuel du ticket;
  SELECT statut INTO v_statut_actuel ;
  FROM tickets ;
  WHERE id = p_ticket_id;
  ;
  IF NOT FOUND THEN ;
    RAISE EXCEPTION 'Ticket % non trouvé', p_ticket_id; 
  END IF;
;
  -- Vérifier que le ticket est au statut 'ouvert' (prêt à diffuser);
  IF v_statut_actuel != 'ouvert' THEN;
    RAISE EXCEPTION 'Ticket doit être au statut ouvert pour diffusion (statut actuel: %)', v_statut_actuel;
  END IF;
;
  -- Validation mode diffusion;
  IF p_mode_diffusion NOT IN ('public', 'assigné') THEN;
    RAISE EXCEPTION 'Mode diffusion invalide: % (attendu: public ou assigné)', p_mode_diffusion;
  END IF;
;
  -- Si mode assigné, entreprise_id obligatoire;
  IF p_mode_diffusion = 'assigné' AND p_entreprise_id IS NULL THEN;
    RAISE EXCEPTION 'Mode assigné nécessite entreprise_id';
  END IF;
;
  -- Si mode public, entreprise_id doit être NULL;
  IF p_mode_diffusion = 'public' AND p_entreprise_id IS NOT NULL THEN;
    RAISE EXCEPTION 'Mode public ne peut pas avoir entreprise_id assignée';
  END IF;
;
  -- Si mode assigné, vérifier que l'entreprise est autorisée par cette régie;
  IF p_mode_diffusion = 'assigné' THEN;
    IF NOT EXISTS (;
      SELECT 1 FROM regies_entreprises ;
      WHERE regie_id = v_regie_id ;
      AND entreprise_id = p_entreprise_id;
    ) THEN;
      RAISE EXCEPTION 'Entreprise % non autorisée par régie %', p_entreprise_id, v_regie_id;
    END IF;
  END IF;
;
  -- Appliquer diffusion;
  UPDATE tickets ;
  SET mode_diffusion = p_mode_diffusion,;
      entreprise_id = p_entreprise_id,;
      updated_at = now();
  WHERE id = p_ticket_id;
;
  -- Changer statut ouvert → en_attente via RPC update_ticket_statut;
  PERFORM update_ticket_statut(p_ticket_id, 'en_attente');
END;
$function$;
"
public,float4_dist,real, real"",""CREATE OR REPLACE FUNCTION public.float4_dist(real, real)";
 RETURNS real;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$float4_dist$function$;
"
public,float8_dist,double precision, double precision"",""CREATE OR REPLACE FUNCTION public.float8_dist(double precision, double precision)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$float8_dist$function$;
"
public,gbt_bit_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_bit_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_compress$function$;
"
public,gbt_bit_consistent,internal, bit, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bit_consistent(internal, bit, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_consistent$function$;
"
public,gbt_bit_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bit_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_penalty$function$;
"
public,gbt_bit_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bit_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_picksplit$function$;
"
public,gbt_bit_same,gbtreekey_var, gbtreekey_var, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bit_same(gbtreekey_var, gbtreekey_var, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_same$function$;
"
public,gbt_bit_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bit_union(internal, internal)";
 RETURNS gbtreekey_var;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bit_union$function$;
"
public,gbt_bool_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_bool_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_compress$function$;
"
public,gbt_bool_consistent,internal, boolean, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bool_consistent(internal, boolean, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_consistent$function$;
"
public,gbt_bool_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_bool_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_fetch$function$;
"
public,gbt_bool_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bool_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_penalty$function$;
"
public,gbt_bool_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bool_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_picksplit$function$;
"
public,gbt_bool_same,gbtreekey2, gbtreekey2, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bool_same(gbtreekey2, gbtreekey2, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_same$function$;
"
public,gbt_bool_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bool_union(internal, internal)";
 RETURNS gbtreekey2;
 LANGUAGE c;
 IMMUTABLE STRICT;
AS '$libdir/btree_gist', $function$gbt_bool_union$function$;
"
public,gbt_bpchar_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_bpchar_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bpchar_compress$function$;
"
public,gbt_bpchar_consistent,internal, character, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bpchar_consistent(internal, character, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bpchar_consistent$function$;
"
public,gbt_bytea_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_bytea_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_compress$function$;
"
public,gbt_bytea_consistent,internal, bytea, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bytea_consistent(internal, bytea, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_consistent$function$;
"
public,gbt_bytea_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bytea_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_penalty$function$;
"
public,gbt_bytea_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bytea_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_picksplit$function$;
"
public,gbt_bytea_same,gbtreekey_var, gbtreekey_var, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bytea_same(gbtreekey_var, gbtreekey_var, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_same$function$;
"
public,gbt_bytea_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_bytea_union(internal, internal)";
 RETURNS gbtreekey_var;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_bytea_union$function$;
"
public,gbt_cash_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_cash_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_compress$function$;
"
public,gbt_cash_consistent,internal, money, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_consistent(internal, money, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_consistent$function$;
"
public,gbt_cash_distance,internal, money, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_distance(internal, money, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_distance$function$;
"
public,gbt_cash_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_cash_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_fetch$function$;
"
public,gbt_cash_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_penalty$function$;
"
public,gbt_cash_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_picksplit$function$;
"
public,gbt_cash_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_same$function$;
"
public,gbt_cash_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_cash_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_cash_union$function$;
"
public,gbt_date_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_date_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_compress$function$;
"
public,gbt_date_consistent,internal, date, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_consistent(internal, date, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_consistent$function$;
"
public,gbt_date_distance,internal, date, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_distance(internal, date, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_distance$function$;
"
public,gbt_date_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_date_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_fetch$function$;
"
public,gbt_date_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_penalty$function$;
"
public,gbt_date_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_picksplit$function$;
"
public,gbt_date_same,gbtreekey8, gbtreekey8, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_same(gbtreekey8, gbtreekey8, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_same$function$;
"
public,gbt_date_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_date_union(internal, internal)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_date_union$function$;
"
public,gbt_decompress,internal,CREATE OR REPLACE FUNCTION public.gbt_decompress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_decompress$function$;
"
public,gbt_enum_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_enum_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_compress$function$;
"
public,gbt_enum_consistent,internal, anyenum, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_enum_consistent(internal, anyenum, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_consistent$function$;
"
public,gbt_enum_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_enum_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_fetch$function$;
"
public,gbt_enum_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_enum_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_penalty$function$;
"
public,gbt_enum_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_enum_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_picksplit$function$;
"
public,gbt_enum_same,gbtreekey8, gbtreekey8, internal"",""CREATE OR REPLACE FUNCTION public.gbt_enum_same(gbtreekey8, gbtreekey8, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_same$function$;
"
public,gbt_enum_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_enum_union(internal, internal)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_enum_union$function$;
"
public,gbt_float4_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_float4_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_compress$function$;
"
public,gbt_float4_consistent,internal, real, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_consistent(internal, real, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_consistent$function$;
"
public,gbt_float4_distance,internal, real, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_distance(internal, real, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_distance$function$;
"
public,gbt_float4_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_float4_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_fetch$function$;
"
public,gbt_float4_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_penalty$function$;
"
public,gbt_float4_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_picksplit$function$;
"
public,gbt_float4_same,gbtreekey8, gbtreekey8, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_same(gbtreekey8, gbtreekey8, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_same$function$;
"
public,gbt_float4_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float4_union(internal, internal)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float4_union$function$;
"
public,gbt_float8_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_float8_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_compress$function$;
"
public,gbt_float8_consistent,internal, double precision, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_consistent(internal, double precision, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_consistent$function$;
"
public,gbt_float8_distance,internal, double precision, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_distance(internal, double precision, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_distance$function$;
"
public,gbt_float8_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_float8_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_fetch$function$;
"
public,gbt_float8_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_penalty$function$;
"
public,gbt_float8_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_picksplit$function$;
"
public,gbt_float8_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_same$function$;
"
public,gbt_float8_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_float8_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_float8_union$function$;
"
public,gbt_inet_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_inet_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_compress$function$;
"
public,gbt_inet_consistent,internal, inet, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_inet_consistent(internal, inet, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_consistent$function$;
"
public,gbt_inet_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_inet_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_penalty$function$;
"
public,gbt_inet_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_inet_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_picksplit$function$;
"
public,gbt_inet_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_inet_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_same$function$;
"
public,gbt_inet_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_inet_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_inet_union$function$;
"
public,gbt_int2_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_int2_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_compress$function$;
"
public,gbt_int2_consistent,internal, smallint, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_consistent(internal, smallint, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_consistent$function$;
"
public,gbt_int2_distance,internal, smallint, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_distance(internal, smallint, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_distance$function$;
"
public,gbt_int2_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_int2_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_fetch$function$;
"
public,gbt_int2_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_penalty$function$;
"
public,gbt_int2_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_picksplit$function$;
"
public,gbt_int2_same,gbtreekey4, gbtreekey4, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_same(gbtreekey4, gbtreekey4, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_same$function$;
"
public,gbt_int2_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int2_union(internal, internal)";
 RETURNS gbtreekey4;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int2_union$function$;
"
public,gbt_int4_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_int4_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_compress$function$;
"
public,gbt_int4_consistent,internal, integer, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_consistent(internal, integer, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_consistent$function$;
"
public,gbt_int4_distance,internal, integer, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_distance(internal, integer, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_distance$function$;
"
public,gbt_int4_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_int4_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_fetch$function$;
"
public,gbt_int4_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_penalty$function$;
"
public,gbt_int4_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_picksplit$function$;
"
public,gbt_int4_same,gbtreekey8, gbtreekey8, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_same(gbtreekey8, gbtreekey8, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_same$function$;
"
public,gbt_int4_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int4_union(internal, internal)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int4_union$function$;
"
public,gbt_int8_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_int8_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_compress$function$;
"
public,gbt_int8_consistent,internal, bigint, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_consistent(internal, bigint, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_consistent$function$;
"
public,gbt_int8_distance,internal, bigint, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_distance(internal, bigint, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_distance$function$;
"
public,gbt_int8_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_int8_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_fetch$function$;
"
public,gbt_int8_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_penalty$function$;
"
public,gbt_int8_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_picksplit$function$;
"
public,gbt_int8_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_same$function$;
"
public,gbt_int8_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_int8_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_int8_union$function$;
"
public,gbt_intv_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_intv_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_compress$function$;
"
public,gbt_intv_consistent,internal, interval, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_consistent(internal, interval, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_consistent$function$;
"
public,gbt_intv_decompress,internal,CREATE OR REPLACE FUNCTION public.gbt_intv_decompress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_decompress$function$;
"
public,gbt_intv_distance,internal, interval, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_distance(internal, interval, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_distance$function$;
"
public,gbt_intv_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_intv_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_fetch$function$;
"
public,gbt_intv_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_penalty$function$;
"
public,gbt_intv_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_picksplit$function$;
"
public,gbt_intv_same,gbtreekey32, gbtreekey32, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_same(gbtreekey32, gbtreekey32, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_same$function$;
"
public,gbt_intv_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_intv_union(internal, internal)";
 RETURNS gbtreekey32;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_intv_union$function$;
"
public,gbt_macad8_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_macad8_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_compress$function$;
"
public,gbt_macad8_consistent,internal, macaddr8, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad8_consistent(internal, macaddr8, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_consistent$function$;
"
public,gbt_macad8_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_macad8_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_fetch$function$;
"
public,gbt_macad8_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad8_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_penalty$function$;
"
public,gbt_macad8_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad8_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_picksplit$function$;
"
public,gbt_macad8_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad8_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_same$function$;
"
public,gbt_macad8_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad8_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad8_union$function$;
"
public,gbt_macad_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_macad_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_compress$function$;
"
public,gbt_macad_consistent,internal, macaddr, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad_consistent(internal, macaddr, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_consistent$function$;
"
public,gbt_macad_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_macad_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_fetch$function$;
"
public,gbt_macad_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_penalty$function$;
"
public,gbt_macad_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_picksplit$function$;
"
public,gbt_macad_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_same$function$;
"
public,gbt_macad_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_macad_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_macad_union$function$;
"
public,gbt_numeric_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_numeric_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_compress$function$;
"
public,gbt_numeric_consistent,internal, numeric, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_numeric_consistent(internal, numeric, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_consistent$function$;
"
public,gbt_numeric_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_numeric_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_penalty$function$;
"
public,gbt_numeric_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_numeric_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_picksplit$function$;
"
public,gbt_numeric_same,gbtreekey_var, gbtreekey_var, internal"",""CREATE OR REPLACE FUNCTION public.gbt_numeric_same(gbtreekey_var, gbtreekey_var, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_same$function$;
"
public,gbt_numeric_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_numeric_union(internal, internal)";
 RETURNS gbtreekey_var;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_numeric_union$function$;
"
public,gbt_oid_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_oid_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_compress$function$;
"
public,gbt_oid_consistent,internal, oid, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_consistent(internal, oid, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_consistent$function$;
"
public,gbt_oid_distance,internal, oid, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_distance(internal, oid, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_distance$function$;
"
public,gbt_oid_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_oid_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_fetch$function$;
"
public,gbt_oid_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_penalty$function$;
"
public,gbt_oid_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_picksplit$function$;
"
public,gbt_oid_same,gbtreekey8, gbtreekey8, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_same(gbtreekey8, gbtreekey8, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_same$function$;
"
public,gbt_oid_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_oid_union(internal, internal)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_oid_union$function$;
"
public,gbt_text_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_text_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_compress$function$;
"
public,gbt_text_consistent,internal, text, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_text_consistent(internal, text, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_consistent$function$;
"
public,gbt_text_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_text_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_penalty$function$;
"
public,gbt_text_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_text_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_picksplit$function$;
"
public,gbt_text_same,gbtreekey_var, gbtreekey_var, internal"",""CREATE OR REPLACE FUNCTION public.gbt_text_same(gbtreekey_var, gbtreekey_var, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_same$function$;
"
public,gbt_text_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_text_union(internal, internal)";
 RETURNS gbtreekey_var;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_text_union$function$;
"
public,gbt_time_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_time_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_compress$function$;
"
public,gbt_time_consistent,internal, time without time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_consistent(internal, time without time zone, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_consistent$function$;
"
public,gbt_time_distance,internal, time without time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_distance(internal, time without time zone, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_distance$function$;
"
public,gbt_time_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_time_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_fetch$function$;
"
public,gbt_time_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_penalty$function$;
"
public,gbt_time_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_picksplit$function$;
"
public,gbt_time_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_same$function$;
"
public,gbt_time_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_time_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_time_union$function$;
"
public,gbt_timetz_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_timetz_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_timetz_compress$function$;
"
public,gbt_timetz_consistent,internal, time with time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_timetz_consistent(internal, time with time zone, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_timetz_consistent$function$;
"
public,gbt_ts_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_ts_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_compress$function$;
"
public,gbt_ts_consistent,internal, timestamp without time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_consistent(internal, timestamp without time zone, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_consistent$function$;
"
public,gbt_ts_distance,internal, timestamp without time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_distance(internal, timestamp without time zone, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_distance$function$;
"
public,gbt_ts_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_ts_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_fetch$function$;
"
public,gbt_ts_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_penalty$function$;
"
public,gbt_ts_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_picksplit$function$;
"
public,gbt_ts_same,gbtreekey16, gbtreekey16, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_same(gbtreekey16, gbtreekey16, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_same$function$;
"
public,gbt_ts_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_ts_union(internal, internal)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_ts_union$function$;
"
public,gbt_tstz_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_tstz_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_tstz_compress$function$;
"
public,gbt_tstz_consistent,internal, timestamp with time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_tstz_consistent(internal, timestamp with time zone, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_tstz_consistent$function$;
"
public,gbt_tstz_distance,internal, timestamp with time zone, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_tstz_distance(internal, timestamp with time zone, smallint, oid, internal)";
 RETURNS double precision;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_tstz_distance$function$;
"
public,gbt_uuid_compress,internal,CREATE OR REPLACE FUNCTION public.gbt_uuid_compress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_compress$function$;
"
public,gbt_uuid_consistent,internal, uuid, smallint, oid, internal"",""CREATE OR REPLACE FUNCTION public.gbt_uuid_consistent(internal, uuid, smallint, oid, internal)";
 RETURNS boolean;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_consistent$function$;
"
public,gbt_uuid_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_uuid_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_fetch$function$;
"
public,gbt_uuid_penalty,internal, internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_uuid_penalty(internal, internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_penalty$function$;
"
public,gbt_uuid_picksplit,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_uuid_picksplit(internal, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_picksplit$function$;
"
public,gbt_uuid_same,gbtreekey32, gbtreekey32, internal"",""CREATE OR REPLACE FUNCTION public.gbt_uuid_same(gbtreekey32, gbtreekey32, internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_same$function$;
"
public,gbt_uuid_union,internal, internal"",""CREATE OR REPLACE FUNCTION public.gbt_uuid_union(internal, internal)";
 RETURNS gbtreekey32;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_uuid_union$function$;
"
public,gbt_var_decompress,internal,CREATE OR REPLACE FUNCTION public.gbt_var_decompress(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_var_decompress$function$;
"
public,gbt_var_fetch,internal,CREATE OR REPLACE FUNCTION public.gbt_var_fetch(internal)";
 RETURNS internal;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbt_var_fetch$function$;
"
public,gbtreekey16_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey16_in(cstring)";
 RETURNS gbtreekey16;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey16_out,gbtreekey16,CREATE OR REPLACE FUNCTION public.gbtreekey16_out(gbtreekey16)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,gbtreekey2_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey2_in(cstring)";
 RETURNS gbtreekey2;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey2_out,gbtreekey2,CREATE OR REPLACE FUNCTION public.gbtreekey2_out(gbtreekey2)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,gbtreekey32_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey32_in(cstring)";
 RETURNS gbtreekey32;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey32_out,gbtreekey32,CREATE OR REPLACE FUNCTION public.gbtreekey32_out(gbtreekey32)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,gbtreekey4_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey4_in(cstring)";
 RETURNS gbtreekey4;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey4_out,gbtreekey4,CREATE OR REPLACE FUNCTION public.gbtreekey4_out(gbtreekey4)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,gbtreekey8_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey8_in(cstring)";
 RETURNS gbtreekey8;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey8_out,gbtreekey8,CREATE OR REPLACE FUNCTION public.gbtreekey8_out(gbtreekey8)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,gbtreekey_var_in,cstring,CREATE OR REPLACE FUNCTION public.gbtreekey_var_in(cstring)";
 RETURNS gbtreekey_var;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_in$function$;
"
public,gbtreekey_var_out,gbtreekey_var,CREATE OR REPLACE FUNCTION public.gbtreekey_var_out(gbtreekey_var)";
 RETURNS cstring;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$gbtreekey_out$function$;
"
public,generate_facture_from_mission,p_mission_id uuid, p_montant_ht numeric, p_date_echeance date, p_taux_tva numeric, p_taux_commission numeric"",""CREATE OR REPLACE FUNCTION public.generate_facture_from_mission(p_mission_id uuid, p_montant_ht numeric, p_date_echeance date DEFAULT (CURRENT_DATE + '30 days'::interval), p_taux_tva numeric DEFAULT 20.00, p_taux_commission numeric DEFAULT 10.00)";
 RETURNS factures;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_mission record;
  v_facture factures;
  v_numero text;
  v_year text;
  v_seq int;
begin;
  -- Vérifier que la mission existe et est validée;
  select * into v_mission from missions where id = p_mission_id;
  ;
  if not found then;
    raise exception 'Mission non trouvée';
  end if;
  ;
  if v_mission.statut != 'validee' then;
    raise exception 'La mission doit être validée pour générer une facture';
  end if;
  ;
  -- Vérifier qu'aucune facture n'existe déjà;
  if exists (select 1 from factures where mission_id = p_mission_id) then;
    raise exception 'Une facture existe déjà pour cette mission';
  end if;
  ;
  -- Générer le numéro de facture (format: FAC-YYYY-NNNN);
  v_year := to_char(current_date, 'YYYY');
  ;
  select coalesce(max(;
    case ;
      when numero ~ '^FAC-[0-9]{4}-[0-9]+$' ;
      then cast(substring(numero from 'FAC-[0-9]{4}-([0-9]+)') as int);
      else 0;
    end;
  ), 0) + 1;
  into v_seq;
  from factures;
  where numero like 'FAC-' || v_year || '-%';
  ;
  v_numero := 'FAC-' || v_year || '-' || lpad(v_seq::text, 4, '0');
  ;
  -- Créer la facture;
  insert into factures (;
    mission_id,;
    entreprise_id,;
    regie_id,;
    numero,;
    montant_ht,;
    taux_tva,;
    taux_commission,;
    date_echeance;
  );
  values (;
    p_mission_id,;
    v_mission.entreprise_id,;
    (select regie_id from tickets where id = v_mission.ticket_id),;
    v_numero,;
    p_montant_ht,;
    p_taux_tva,;
    p_taux_commission,;
    p_date_echeance;
  );
  returning * into v_facture;
  ;
  return v_facture;
end;
$function$;
"
public,get_current_plan,p_entreprise_id uuid, p_regie_id uuid"",""CREATE OR REPLACE FUNCTION public.get_current_plan(p_entreprise_id uuid DEFAULT NULL::uuid, p_regie_id uuid DEFAULT NULL::uuid)";
 RETURNS TABLE(abonnement_id uuid, plan_id uuid, plan_nom character varying, statut character varying, date_fin date, limite_missions_mois integer, limite_techniciens integer, limite_utilisateurs integer, modules_actifs jsonb);
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
BEGIN;
    RETURN QUERY;
    SELECT ;
        a.id,;
        p.id,;
        p.nom,;
        a.statut,;
        a.date_fin,;
        p.limite_missions_mois,;
        p.limite_techniciens,;
        p.limite_utilisateurs,;
        p.modules_actifs;
    FROM public.abonnements a;
    JOIN public.plans p ON a.plan_id = p.id;
    WHERE ;
        (p_entreprise_id IS NOT NULL AND a.entreprise_id = p_entreprise_id) OR;
        (p_regie_id IS NOT NULL AND a.regie_id = p_regie_id);
    AND a.statut = 'actif';
    ORDER BY a.created_at DESC;
    LIMIT 1;
END;
$function$;
"
public,get_mission_actors,p_mission_id uuid,CREATE OR REPLACE FUNCTION public.get_mission_actors(p_mission_id uuid)";
 RETURNS TABLE(user_id uuid, role text);
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
begin;
  return query;
  select distinct au.id, au.role;
  from missions m;
    join tickets t on m.ticket_id = t.id;
    join profiles au on (;
      -- Entreprise;
      au.entreprise_id = m.entreprise_id;
      -- Technicien assigné;
      or (m.technicien_id is not null and exists (;
        select 1 from techniciens tech ;
        where tech.id = m.technicien_id ;
        and tech.profile_id = au.id;
      ));
      -- Régie;
      or au.regie_id = t.regie_id;
      -- Locataire;
      or au.locataire_id = t.locataire_id;
    );
  where m.id = p_mission_id;
end;
$function$;
"
public,get_user_regie_id,,CREATE OR REPLACE FUNCTION public.get_user_regie_id()";
 RETURNS uuid;
 LANGUAGE sql;
 STABLE SECURITY DEFINER;
AS $function$;
  select regie_id from (;
    -- Pour le rôle 'regie', prendre directement depuis regies;
    select r.id as regie_id;
    from regies r;
    where r.profile_id = auth.uid();
    ;
    union;
    ;
    -- Pour le rôle 'locataire', remonter via logements → immeubles;
    select i.regie_id;
    from locataires l;
    join logements lg on lg.id = l.logement_id;
    join immeubles i on i.id = lg.immeuble_id;
    where l.profile_id = auth.uid();
    ;
    limit 1;
  ) as user_regie;
$function$;
"
public,get_user_technicien_id,,CREATE OR REPLACE FUNCTION public.get_user_technicien_id()";
 RETURNS uuid;
 LANGUAGE sql;
 STABLE SECURITY DEFINER;
AS $function$;
  select id from techniciens;
  where profile_id = auth.uid();
  limit 1;
$function$;
"
public,handle_updated_at,,CREATE OR REPLACE FUNCTION public.handle_updated_at()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
  new.updated_at = now();
  return new;
end;
$function$;
"
public,increment_mission_quota,p_entreprise_id uuid,CREATE OR REPLACE FUNCTION public.increment_mission_quota(p_entreprise_id uuid)";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_abonnement_id UUID;
BEGIN;
    -- Trouver l'abonnement actif;
    SELECT id INTO v_abonnement_id;
    FROM public.abonnements;
    WHERE entreprise_id = p_entreprise_id;
    AND statut = 'actif';
    ORDER BY created_at DESC;
    LIMIT 1;
    ;
    IF FOUND THEN;
        -- Incrémenter le compteur;
        UPDATE public.abonnements;
        SET missions_ce_mois = missions_ce_mois + 1,;
            updated_at = now();
        WHERE id = v_abonnement_id;
    END IF;
END;
$function$;
"
public,increment_quota_on_mission,,CREATE OR REPLACE FUNCTION public.increment_quota_on_mission()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
BEGIN;
    -- Incrémenter le quota si c'est une entreprise;
    IF NEW.entreprise_id IS NOT NULL THEN;
        PERFORM public.increment_mission_quota(NEW.entreprise_id);
    END IF;
    ;
    RETURN NEW;
END;
$function$;
"
public,int2_dist,smallint, smallint"",""CREATE OR REPLACE FUNCTION public.int2_dist(smallint, smallint)";
 RETURNS smallint;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$int2_dist$function$;
"
public,int4_dist,integer, integer"",""CREATE OR REPLACE FUNCTION public.int4_dist(integer, integer)";
 RETURNS integer;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$int4_dist$function$;
"
public,int8_dist,bigint, bigint"",""CREATE OR REPLACE FUNCTION public.int8_dist(bigint, bigint)";
 RETURNS bigint;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$int8_dist$function$;
"
public,interval_dist,interval, interval"",""CREATE OR REPLACE FUNCTION public.interval_dist(interval, interval)";
 RETURNS interval;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$interval_dist$function$;
"
public,is_admin_jtec,,CREATE OR REPLACE FUNCTION public.is_admin_jtec()";
 RETURNS boolean;
 LANGUAGE sql;
 STABLE SECURITY DEFINER;
AS $function$;
  select exists (;
    select 1 from profiles;
    where id = auth.uid();
    and role = 'admin_jtec';
  );
$function$;
"
public,liberer_logement_locataire,p_locataire_id uuid, p_date_sortie date"",""CREATE OR REPLACE FUNCTION public.liberer_logement_locataire(p_locataire_id uuid, p_date_sortie date DEFAULT CURRENT_DATE)";
 RETURNS json;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_logement_id uuid;
  v_ancien_statut text;
BEGIN;
  -- ========================================;
  -- 1. Vérifier que locataire appartient à la régie connectée;
  -- ========================================;
  SELECT l.logement_id INTO v_logement_id;
  FROM locataires l;
  JOIN logements lg ON lg.id = l.logement_id;
  JOIN immeubles i ON i.id = lg.immeuble_id;
  WHERE l.id = p_locataire_id;
    AND i.regie_id = get_user_regie_id();
  ;
  IF NOT FOUND THEN;
    RAISE EXCEPTION 'Locataire non trouvé ou vous n''avez pas les droits';
  END IF;
  ;
  -- ========================================;
  -- 2. Mettre date_sortie locataire;
  -- ========================================;
  UPDATE locataires;
  SET date_sortie = p_date_sortie;
  WHERE id = p_locataire_id;
  ;
  -- ========================================;
"  -- 3. Changer statut logement en """"vacant""""";
  -- ========================================;
  UPDATE logements;
  SET statut = 'vacant';
  WHERE id = v_logement_id;
  RETURNING statut INTO v_ancien_statut;
  ;
  -- ========================================;
  -- 4. Retourner résultat;
  -- ========================================;
  RETURN json_build_object(;
    'success', true,;
    'locataire_id', p_locataire_id,;
    'logement_id', v_logement_id,;
    'date_sortie', p_date_sortie,;
    'logement_statut', 'vacant',;
    'message', 'Logement libéré avec succès';
  );
  ;
EXCEPTION;
  WHEN OTHERS THEN;
    RAISE EXCEPTION 'Erreur libération logement : %', SQLERRM;
END;
$function$;
"
public,mark_notification_as_read,p_notification_id uuid, p_user_id uuid"",""CREATE OR REPLACE FUNCTION public.mark_notification_as_read(p_notification_id uuid, p_user_id uuid)";
 RETURNS notifications;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_notification notifications;
begin;
  -- Vérifier que la notification appartient à l'utilisateur;
  select * into v_notification ;
  from notifications ;
  where id = p_notification_id and user_id = p_user_id;
  ;
  if not found then;
    raise exception 'Notification non trouvée';
  end if;
  ;
  -- Marquer comme lue;
  update notifications;
  set read = true,;
      read_at = now();
  where id = p_notification_id;
  returning * into v_notification;
  ;
  return v_notification;
end;
$function$;
"
public,notify_facture_status_change,,CREATE OR REPLACE FUNCTION public.notify_facture_status_change()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
  if OLD.statut is distinct from NEW.statut then;
    perform pg_notify('facture_status_change', json_build_object(;
      'facture_id', NEW.id,;
      'numero', NEW.numero,;
      'ancien_statut', OLD.statut,;
      'nouveau_statut', NEW.statut,;
      'entreprise_id', NEW.entreprise_id,;
      'regie_id', NEW.regie_id;
    )::text);
  end if;
  return NEW;
end;
$function$;
"
public,notify_mission_status_change,,CREATE OR REPLACE FUNCTION public.notify_mission_status_change()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
  -- Log simple du changement (pour audit);
  if old.statut is distinct from new.statut then;
    raise notice 'Mission % : statut changé de % à %', new.id, old.statut, new.statut;
  end if;
  ;
  return new;
end;
$function$;
"
public,notify_mission_status_change_extended,,CREATE OR REPLACE FUNCTION public.notify_mission_status_change_extended()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
declare;
  v_actor record;
  v_mission_ref text;
begin;
  if OLD.statut is distinct from NEW.statut then;
    -- Récupérer la référence;
    v_mission_ref := NEW.reference;
    ;
    -- Message système dans la messagerie;
    perform create_system_message(;
      NEW.id,;
      'Statut changé : ' || OLD.statut || ' → ' || NEW.statut;
    );
    ;
    -- Notifications pour tous les acteurs;
    for v_actor in select * from get_mission_actors(NEW.id);
    loop;
      insert into notifications (;
        user_id,;
        type,;
        title,;
        message,;
        related_mission_id;
      );
      values (;
        v_actor.user_id,;
        'mission_status_change',;
        'Changement de statut - ' || v_mission_ref,;
        'La mission est maintenant : ' || NEW.statut,;
        NEW.id;
      );
    end loop;
  end if;
  ;
  return NEW;
end;
$function$;
"
public,notify_new_ticket,,CREATE OR REPLACE FUNCTION public.notify_new_ticket()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
declare;
  v_actor record;
begin;
  -- Notifier la régie et le locataire;
  for v_actor in ;
    select id from profiles ;
    where regie_id = NEW.regie_id or locataire_id = NEW.locataire_id;
  loop;
    insert into notifications (;
      user_id,;
      type,;
      title,;
      message,;
      related_ticket_id;
    );
    values (;
      v_actor.user_id,;
      'new_ticket',;
      'Nouveau ticket créé',;
      'Ticket ' || NEW.numero || ' : ' || left(NEW.description, 100),;
      NEW.id;
    );
  end loop;
  ;
  return NEW;
end;
$function$;
"
public,notify_technicien_assignment,,CREATE OR REPLACE FUNCTION public.notify_technicien_assignment()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
declare;
  v_tech_user_id uuid;
  v_mission_ref text;
  v_tech_nom text;
begin;
  -- Uniquement si technicien assigné (avant NULL, maintenant non NULL);
  if OLD.technicien_id is null and NEW.technicien_id is not null then;
    -- Récupérer le user_id du technicien;
    select user_id, nom into v_tech_user_id, v_tech_nom;
    from techniciens;
    where id = NEW.technicien_id;
    ;
    if v_tech_user_id is not null then;
      v_mission_ref := NEW.reference;
      ;
      -- Message système;
      perform create_system_message(;
        NEW.id,;
        'Technicien assigné : ' || v_tech_nom;
      );
      ;
      -- Notification pour le technicien;
      insert into notifications (;
        user_id,;
        type,;
        title,;
        message,;
        related_mission_id;
      );
      values (;
        v_tech_user_id,;
        'mission_assigned',;
        'Nouvelle mission assignée',;
        'Vous avez été assigné à la mission ' || v_mission_ref,;
        NEW.id;
      );
    end if;
  end if;
  ;
  return NEW;
end;
$function$;
"
public,oid_dist,oid, oid"",""CREATE OR REPLACE FUNCTION public.oid_dist(oid, oid)";
 RETURNS oid;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$oid_dist$function$;
"
public,prevent_role_self_escalation,,CREATE OR REPLACE FUNCTION public.prevent_role_self_escalation()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_user_role text;
  v_is_admin boolean := false;
begin;
  -- 1. Récupérer le rôle de l'utilisateur qui fait la modification;
  select role into v_current_user_role;
  from profiles;
  where id = auth.uid();
  ;
  -- 2. Vérifier si l'utilisateur est admin_jtec;
  if v_current_user_role = 'admin_jtec' then;
    v_is_admin := true;
  end if;
  ;
  -- 3. Si le champ 'role' est modifié;
  if OLD.role is distinct from NEW.role then;
    -- 3a. Si l'utilisateur modifie son propre rôle;
    if OLD.id = auth.uid() then;
      -- Même un admin ne peut pas changer son propre rôle;
      -- Cela évite qu'un admin se rétrograde par erreur;
      raise exception 'SÉCURITÉ: Impossible de modifier son propre rôle. Contactez un autre administrateur.';
    end if;
    ;
    -- 3b. Si ce n'est pas un admin qui modifie le rôle d'un autre utilisateur;
    if not v_is_admin then;
      raise exception 'SÉCURITÉ: Seul un admin_jtec peut modifier le rôle d''un utilisateur.';
    end if;
    ;
    -- 3c. Log de la modification (audit);
    raise notice 'AUDIT: Admin % a changé le rôle de % : % → %', ;
      auth.uid(), ;
      NEW.id, ;
      OLD.role, ;
      NEW.role;
  end if;
  ;
  -- 4. Autoriser la modification;
  return NEW;
end;
$function$;
"
public,refuser_agence,p_regie_id uuid, p_admin_id uuid, p_commentaire text"",""CREATE OR REPLACE FUNCTION public.refuser_agence(p_regie_id uuid, p_admin_id uuid, p_commentaire text)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_admin_role text;
  v_regie_email text;
  v_regie_nom text;
begin;
  -- 1. Vérifier que c'est bien un admin_jtec;
  select role into v_admin_role;
  from profiles;
  where id = p_admin_id;
  ;
  if v_admin_role != 'admin_jtec' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Seul un admin JTEC peut refuser une agence';
    );
  end if;
  ;
  -- 2. Validation du commentaire;
  if p_commentaire is null or trim(p_commentaire) = '' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Un commentaire est obligatoire pour refuser une agence';
    );
  end if;
  ;
  -- 3. Vérifier que la régie existe et est en attente;
  if not exists (;
    select 1 from regies;
    where id = p_regie_id;
    and statut_validation = 'en_attente';
  ) then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Régie non trouvée ou déjà validée/refusée';
    );
  end if;
  ;
  -- 4. Refuser la régie;
  update regies;
  set ;
    statut_validation = 'refuse',;
    date_validation = now(),;
    admin_validateur_id = p_admin_id,;
    commentaire_refus = p_commentaire;
  where id = p_regie_id;
  returning email, nom into v_regie_email, v_regie_nom;
  ;
  -- 5. Log;
  raise notice 'AUDIT: Admin % a refusé l''agence % (ID: %): %', p_admin_id, v_regie_nom, p_regie_id, p_commentaire;
  ;
  -- TODO: Envoyer notification email à la régie;
  ;
  return jsonb_build_object(;
    'success', true,;
    'message', 'Agence refusée',;
    'regie_email', v_regie_email,;
    'regie_nom', v_regie_nom;
  );
end;
$function$;
"
public,send_message,p_mission_id uuid, p_sender_user_id uuid, p_content text"",""CREATE OR REPLACE FUNCTION public.send_message(p_mission_id uuid, p_sender_user_id uuid, p_content text)";
 RETURNS messages;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_message messages;
  v_sender profiles;
  v_actor record;
  v_mission_ref text;
begin;
  -- Vérifier que la mission existe;
  if not exists (select 1 from missions where id = p_mission_id) then;
    raise exception 'Mission non trouvée';
  end if;
  ;
  -- Récupérer les infos de l'expéditeur;
  select * into v_sender from profiles where id = p_sender_user_id;
  ;
  if not found then;
    raise exception 'Utilisateur non trouvé';
  end if;
  ;
  -- Vérifier que l'expéditeur est un acteur de la mission;
  if not exists (;
    select 1 from get_mission_actors(p_mission_id) ;
    where user_id = p_sender_user_id;
  ) then;
    raise exception 'Accès refusé : vous n''êtes pas acteur de cette mission';
  end if;
  ;
  -- Créer le message;
  insert into messages (;
    mission_id,;
    sender_user_id,;
    sender_name,;
    sender_role,;
    content,;
    type;
  );
  values (;
    p_mission_id,;
    p_sender_user_id,;
    coalesce(v_sender.nom, v_sender.prenom, 'Utilisateur'),;
    v_sender.role,;
    p_content,;
    'message';
  );
  returning * into v_message;
  ;
  -- Récupérer la référence de la mission pour les notifications;
  select reference into v_mission_ref from missions where id = p_mission_id;
  ;
  -- Créer des notifications pour les autres acteurs;
  for v_actor in ;
    select * from get_mission_actors(p_mission_id) ;
    where user_id != p_sender_user_id;
  loop;
    insert into notifications (;
      user_id,;
      type,;
      title,;
      message,;
      related_mission_id,;
      related_message_id;
    );
    values (;
      v_actor.user_id,;
      'new_message',;
      'Nouveau message sur ' || v_mission_ref,;
      v_sender.nom || ' : ' || left(p_content, 100),;
      p_mission_id,;
      v_message.id;
    );
  end loop;
  ;
  return v_message;
end;
$function$;
"
public,set_ticket_regie_id,,CREATE OR REPLACE FUNCTION public.set_ticket_regie_id()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
declare;
  v_regie_id uuid;
begin;
  -- Récupérer la regie_id via logement → immeuble → regie;
  select i.regie_id into v_regie_id;
  from logements l;
  join immeubles i on l.immeuble_id = i.id;
  where l.id = new.logement_id;
  ;
  if v_regie_id is null then;
    raise exception 'Impossible de déterminer la régie pour le logement %', new.logement_id;
  end if;
  ;
  new.regie_id := v_regie_id;
  return new;
end;
$function$;
"
public,start_mission,p_mission_id uuid,CREATE OR REPLACE FUNCTION public.start_mission(p_mission_id uuid)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_statut text;
begin;
  -- 1. Vérifier que la mission existe et récupérer son statut;
  select statut into v_current_statut;
  from missions;
  where id = p_mission_id;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission non trouvée';
    );
  end if;
  ;
  -- 2. Vérifier que la mission est en_attente;
  if v_current_statut != 'en_attente' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'La mission doit être en_attente pour être démarrée (statut actuel: ' || v_current_statut || ')';
    );
  end if;
  ;
  -- 3. Démarrer la mission;
  update missions;
  set ;
    statut = 'en_cours',;
    started_at = now();
  where id = p_mission_id;
  ;
  return jsonb_build_object(;
    'success', true;
  );
end;
$function$;
"
public,sync_ticket_statut_from_mission,,CREATE OR REPLACE FUNCTION public.sync_ticket_statut_from_mission()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_new_ticket_statut ticket_status;
BEGIN;
  -- Synchroniser uniquement si statut mission a changé;
  IF NEW.statut IS DISTINCT FROM OLD.statut THEN;
    ;
    -- Déterminer nouveau statut ticket selon statut mission;
    CASE NEW.statut;
      -- Mission 'en_cours' → Ticket 'en_cours';
      WHEN 'en_cours' THEN;
        v_new_ticket_statut := 'en_cours';
      ;
      -- Mission 'terminee' → Ticket 'termine';
      WHEN 'terminee' THEN;
        v_new_ticket_statut := 'termine';
      ;
      -- Mission 'validee' → Ticket 'clos';
      WHEN 'validee' THEN;
        v_new_ticket_statut := 'clos';
      ;
      -- Autres statuts mission : pas de synchronisation;
      ELSE;
        RETURN NEW;
    END CASE;
    ;
    -- Mettre à jour statut ticket (évite boucle infinie : pas de trigger sur UPDATE tickets.statut pour sync inverse);
    UPDATE tickets;
    SET ;
      statut = v_new_ticket_statut,;
      updated_at = now();
    WHERE id = NEW.ticket_id;
    AND statut != v_new_ticket_statut;  -- Update uniquement si changement nécessaire
    ;
  END IF;
  ;
  RETURN NEW;
END;
$function$;
"
public,ticket_has_mission,p_ticket_id uuid,CREATE OR REPLACE FUNCTION public.ticket_has_mission(p_ticket_id uuid)";
 RETURNS boolean;
 LANGUAGE sql;
 STABLE SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
  SELECT EXISTS (;
    SELECT 1 FROM missions ;
    WHERE ticket_id = p_ticket_id;
  );
$function$;
"
public,time_dist,time without time zone, time without time zone"",""CREATE OR REPLACE FUNCTION public.time_dist(time without time zone, time without time zone)";
 RETURNS interval;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$time_dist$function$;
"
public,ts_dist,timestamp without time zone, timestamp without time zone"",""CREATE OR REPLACE FUNCTION public.ts_dist(timestamp without time zone, timestamp without time zone)";
 RETURNS interval;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$ts_dist$function$;
"
public,tstz_dist,timestamp with time zone, timestamp with time zone"",""CREATE OR REPLACE FUNCTION public.tstz_dist(timestamp with time zone, timestamp with time zone)";
 RETURNS interval;
 LANGUAGE c;
 IMMUTABLE PARALLEL SAFE STRICT;
AS '$libdir/btree_gist', $function$tstz_dist$function$;
"
public,update_abonnement_updated_at,,CREATE OR REPLACE FUNCTION public.update_abonnement_updated_at()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$;
"
public,update_facture_status,p_facture_id uuid, p_nouveau_statut text"",""CREATE OR REPLACE FUNCTION public.update_facture_status(p_facture_id uuid, p_nouveau_statut text)";
 RETURNS factures;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_facture factures;
  v_ancien_statut text;
begin;
  -- Récupérer la facture;
  select * into v_facture from factures where id = p_facture_id;
  ;
  if not found then;
    raise exception 'Facture non trouvée';
  end if;
  ;
  v_ancien_statut := v_facture.statut;
  ;
  -- Vérifier que le nouveau statut est valide;
  if p_nouveau_statut not in ('brouillon', 'envoyee', 'payee', 'annulee') then;
    raise exception 'Statut invalide: %', p_nouveau_statut;
  end if;
  ;
  -- Vérifier les transitions autorisées;
  if v_ancien_statut = 'annulee' then;
    raise exception 'Impossible de modifier une facture annulée';
  end if;
  ;
  if v_ancien_statut = 'payee' and p_nouveau_statut != 'payee' then;
    raise exception 'Impossible de modifier une facture déjà payée';
  end if;
  ;
  -- Valider la séquence logique;
  if v_ancien_statut = 'brouillon' and p_nouveau_statut = 'payee' then;
    raise exception 'Une facture doit être envoyée avant d''être marquée comme payée';
  end if;
  ;
  -- Mettre à jour la facture;
  update factures;
  set statut = p_nouveau_statut,;
      date_envoi = case when p_nouveau_statut = 'envoyee' and date_envoi is null then now() else date_envoi end,;
      date_paiement = case when p_nouveau_statut = 'payee' and date_paiement is null then now() else date_paiement end;
  where id = p_facture_id;
  returning * into v_facture;
  ;
  return v_facture;
end;
$function$;
"
public,update_mission_status,p_mission_id uuid, p_new_status mission_status, p_role user_role"",""CREATE OR REPLACE FUNCTION public.update_mission_status(p_mission_id uuid, p_new_status mission_status, p_role user_role)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_status mission_status;
begin;
  select statut;
  into v_current_status;
  from missions;
  where id = p_mission_id;
;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission introuvable';
    );
  end if;
;
  update missions;
  set;
    statut = p_new_status,;
    updated_at = now();
  where id = p_mission_id;
;
  return jsonb_build_object(;
    'success', true,;
    'ancien_statut', v_current_status,;
    'nouveau_statut', p_new_status;
  );
end;
$function$;
"
public,update_missions_updated_at,,CREATE OR REPLACE FUNCTION public.update_missions_updated_at()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
  new.updated_at = now();
  return new;
end;
$function$;
"
public,update_plan_updated_at,,CREATE OR REPLACE FUNCTION public.update_plan_updated_at()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$;
"
public,update_techniciens_updated_at,,CREATE OR REPLACE FUNCTION public.update_techniciens_updated_at()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
  new.updated_at = now();
  return new;
end;
$function$;
"
public,update_ticket_status,p_ticket_id uuid, p_new_status ticket_status, p_role user_role"",""CREATE OR REPLACE FUNCTION public.update_ticket_status(p_ticket_id uuid, p_new_status ticket_status, p_role user_role)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_status ticket_status;
begin;
  select statut;
  into v_current_status;
  from tickets;
  where id = p_ticket_id;
;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Ticket introuvable';
    );
  end if;
;
  -- règles métier strictes;
  if v_current_status = 'nouveau';
     and p_new_status = 'en_attente';
     and p_role in ('regie', 'admin_jtec') then;
    null;
;
  elsif v_current_status = 'en_attente';
     and p_new_status = 'en_cours';
     and p_role in ('entreprise', 'admin_jtec') then;
    null;
;
  elsif v_current_status = 'en_cours';
     and p_new_status = 'termine';
     and p_role in ('entreprise', 'admin_jtec') then;
    null;
;
  elsif v_current_status = 'termine';
     and p_new_status = 'clos';
     and p_role in ('regie', 'admin_jtec') then;
    null;
;
  elsif p_new_status = 'annule';
     and p_role in ('regie', 'locataire', 'admin_jtec') then;
    null;
;
  else;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Transition non autorisée',;
      'from', v_current_status,;
      'to', p_new_status,;
      'role', p_role;
    );
  end if;
;
  update tickets;
  set;
    statut = p_new_status,;
    updated_at = now(),;
    date_cloture = case;
      when p_new_status in ('clos','annule') then now();
      else date_cloture;
    end;
  where id = p_ticket_id;
;
  return jsonb_build_object(;
    'success', true,;
    'ancien_statut', v_current_status,;
    'nouveau_statut', p_new_status;
  );
end;
$function$;
"
public,update_ticket_statut,p_ticket_id uuid, p_nouveau_statut ticket_status"",""CREATE OR REPLACE FUNCTION public.update_ticket_statut(p_ticket_id uuid, p_nouveau_statut ticket_status)";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO 'public';
AS $function$;
DECLARE;
  v_statut_actuel ticket_status;
  v_user_role text;
BEGIN;
  -- Récupérer statut actuel;
  SELECT statut INTO v_statut_actuel ;
  FROM tickets ;
  WHERE id = p_ticket_id;
  ;
  IF NOT FOUND THEN ;
    RAISE EXCEPTION 'Ticket % non trouvé', p_ticket_id; 
  END IF;
;
  -- Récupérer rôle utilisateur connecté;
  SELECT role INTO v_user_role ;
  FROM profiles ;
  WHERE id = auth.uid();
;
  -- Si statut inchangé, ne rien faire;
  IF v_statut_actuel = p_nouveau_statut THEN ;
    RETURN; 
  END IF;
;
  -- Validation transitions selon statut actuel et rôle;
  -- CORRECTION: 'regie' ET 'admin_jtec' peuvent gérer transitions;
  IF v_statut_actuel = 'nouveau' ;
     AND p_nouveau_statut = 'ouvert' ;
     AND v_user_role IN ('regie', 'admin_jtec') THEN;
    -- Transition nouveau → ouvert (validation par régie/admin);
    NULL; -- OK
    ;
  ELSIF v_statut_actuel = 'ouvert' ;
        AND p_nouveau_statut = 'en_attente' ;
        AND v_user_role IN ('regie', 'admin_jtec') THEN;
    -- Transition ouvert → en_attente (diffusion par régie/admin);
    NULL; -- OK
    ;
  ELSIF v_statut_actuel = 'en_attente' ;
        AND p_nouveau_statut = 'en_cours' THEN;
    -- Transition en_attente → en_cours (acceptation entreprise);
    NULL; -- OK (tout rôle peut tenter, RLS filtrera)
    ;
  ELSIF v_statut_actuel = 'en_cours' ;
        AND p_nouveau_statut = 'termine' THEN;
    -- Transition en_cours → termine (terminaison intervention);
    NULL; -- OK
    ;
  ELSIF v_statut_actuel = 'termine' ;
        AND p_nouveau_statut = 'clos' ;
        AND v_user_role IN ('regie', 'admin_jtec') THEN;
    -- Transition termine → clos (validation finale régie/admin);
    NULL; -- OK
    ;
  ELSIF p_nouveau_statut = 'annule' ;
        AND v_user_role IN ('regie', 'admin_jtec') THEN;
    -- Transition vers annule depuis n'importe quel statut (régie/admin);
    NULL; -- OK
    ;
  ELSE;
    -- Transition interdite;
    RAISE EXCEPTION 'Transition interdite : % → % pour rôle %', ;
      v_statut_actuel, p_nouveau_statut, COALESCE(v_user_role, 'non authentifié');
  END IF;
;
  -- Appliquer transition;
  UPDATE tickets ;
  SET statut = p_nouveau_statut, ;
      updated_at = now(),;
      date_cloture = CASE ;
        WHEN p_nouveau_statut = 'clos' THEN now() ;
        ELSE date_cloture ;
      END;
  WHERE id = p_ticket_id;
END;
$function$;
"
public,validate_mission,p_mission_id uuid,CREATE OR REPLACE FUNCTION public.validate_mission(p_mission_id uuid)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_current_statut text;
  v_signatures_complete boolean;
begin;
  -- 1. Vérifier que la mission existe;
  select ;
    statut,;
    (signature_locataire_url is not null and signature_technicien_url is not null);
  into v_current_statut, v_signatures_complete;
  from missions;
  where id = p_mission_id;
  ;
  if not found then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Mission non trouvée';
    );
  end if;
  ;
  -- 2. Vérifier que la mission est terminee;
  if v_current_statut != 'terminee' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'La mission doit être terminee pour être validée (statut actuel: ' || v_current_statut || ')';
    );
  end if;
  ;
  -- 3. Vérifier que les signatures sont présentes (optionnel mais recommandé);
  if not v_signatures_complete then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Les signatures du locataire et du technicien sont requises',;
      'warning', true;
    );
  end if;
  ;
  -- 4. Valider la mission;
  update missions;
  set ;
    statut = 'validee',;
    validated_at = now();
  where id = p_mission_id;
  ;
  return jsonb_build_object(;
    'success', true;
  );
end;
$function$;
"
public,valider_agence,p_regie_id uuid, p_admin_id uuid"",""CREATE OR REPLACE FUNCTION public.valider_agence(p_regie_id uuid, p_admin_id uuid)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
declare;
  v_admin_role text;
  v_regie_email text;
  v_regie_nom text;
  v_profile_id uuid;  -- ✅ AJOUT : Variable pour stocker profile_id
begin;
  -- 1. Vérifier que c'est bien un admin_jtec;
  select role into v_admin_role;
  from profiles;
  where id = p_admin_id;
  ;
  if v_admin_role != 'admin_jtec' then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Seul un admin JTEC peut valider une agence';
    );
  end if;
  ;
  -- 2. Vérifier que la régie existe et est en attente;
  if not exists (;
    select 1 from regies;
    where id = p_regie_id;
    and statut_validation = 'en_attente';
  ) then;
    return jsonb_build_object(;
      'success', false,;
      'error', 'Régie non trouvée ou déjà validée/refusée';
    );
  end if;
  ;
  -- 3. Valider la régie;
  update regies;
  set ;
    statut_validation = 'valide',;
    date_validation = now(),;
    admin_validateur_id = p_admin_id,;
    commentaire_refus = null;
  where id = p_regie_id;
  returning email, nom, profile_id into v_regie_email, v_regie_nom, v_profile_id;  -- ✅ AJOUT : Récupérer profile_id
  ;
  -- ✅ CORRECTION CRITIQUE : Rattacher le profil créateur à sa régie;
  UPDATE profiles;
  SET regie_id = p_regie_id,;
      updated_at = now();
  WHERE id = v_profile_id;
  ;
  -- Vérification que la mise à jour a réussi;
  IF NOT FOUND THEN;
    -- Rollback implicite (transaction échouée);
    RAISE EXCEPTION 'ERREUR CRITIQUE: Impossible de rattacher le profil % à la régie %. Rollback.', v_profile_id, p_regie_id;
  END IF;
  ;
  -- 4. Log avec confirmation du rattachement;
  raise notice 'AUDIT: Admin % a validé l''agence % (ID: %) et rattaché le profil %', p_admin_id, v_regie_nom, p_regie_id, v_profile_id;
  ;
  -- TODO: Envoyer notification email à la régie;
  ;
  return jsonb_build_object(;
    'success', true,;
    'message', 'Agence validée avec succès et profil rattaché',;
    'regie_email', v_regie_email,;
    'regie_nom', v_regie_nom,;
    'profile_id', v_profile_id,  -- ✅ AJOUT : Pour debug;
    'regie_id_assigned', p_regie_id  -- ✅ AJOUT : Confirmation du rattachement;
  );
end;
$function$;
"
realtime,apply_rls,wal jsonb, max_record_bytes integer"",""CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))";
 RETURNS SETOF realtime.wal_rls;
 LANGUAGE plpgsql;
AS $function$;
declare;
#NOM?;
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;
;
-- I, U, D, T: insert, update ...;
action realtime.action = (;
    case wal ->> 'action';
        when 'I' then 'INSERT';
        when 'U' then 'UPDATE';
        when 'D' then 'DELETE';
        else 'ERROR';
    end;
);
;
#NOM?;
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;
;
subscriptions realtime.subscription[] = array_agg(subs);
    from;
        realtime.subscription subs;
    where;
        subs.entity = entity_;
;
#NOM?;
roles regrole[] = array_agg(distinct us.claims_role::text);
    from;
        unnest(subscriptions) us;
;
working_role regrole;
claimed_role regrole;
claims jsonb;
;
subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';
;
-- structured info for wal's columns;
columns realtime.wal_column[];
#NOM?;
old_columns realtime.wal_column[];
;
error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;
;
#NOM?;
output jsonb;
;
begin;
perform set_config('role', null, true);
;
columns =;
    array_agg(;
        (;
            x->>'name',;
            x->>'type',;
            x->>'typeoid',;
            realtime.cast(;
                (x->'value') #>> '{}',;
                coalesce(;
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4;
                    (x->>'type')::regtype;
                );
            ),;
            (pks ->> 'name') is not null,;
            true;
        )::realtime.wal_column;
    );
    from;
        jsonb_array_elements(wal -> 'columns') x;
        left join jsonb_array_elements(wal -> 'pk') pks;
            on (x ->> 'name') = (pks ->> 'name');
;
old_columns =;
    array_agg(;
        (;
            x->>'name',;
            x->>'type',;
            x->>'typeoid',;
            realtime.cast(;
                (x->'value') #>> '{}',;
                coalesce(;
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4;
                    (x->>'type')::regtype;
                );
            ),;
            (pks ->> 'name') is not null,;
            true;
        )::realtime.wal_column;
    );
    from;
        jsonb_array_elements(wal -> 'identity') x;
        left join jsonb_array_elements(wal -> 'pk') pks;
            on (x ->> 'name') = (pks ->> 'name');
;
for working_role in select * from unnest(roles) loop;
;
    -- Update `is_selectable` for columns and old_columns;
    columns =;
        array_agg(;
            (;
                c.name,;
                c.type_name,;
                c.type_oid,;
                c.value,;
                c.is_pkey,;
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT');
            )::realtime.wal_column;
        );
        from;
            unnest(columns) c;
;
    old_columns =;
            array_agg(;
                (;
                    c.name,;
                    c.type_name,;
                    c.type_oid,;
                    c.value,;
                    c.is_pkey,;
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT');
                )::realtime.wal_column;
            );
            from;
                unnest(old_columns) c;
;
    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then;
        return next (;
            jsonb_build_object(;
                'schema', wal ->> 'schema',;
                'table', wal ->> 'table',;
                'type', action;
            ),;
            is_rls_enabled,;
            -- subscriptions is already filtered by entity;
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),;
            array['Error 400: Bad Request, no primary key'];
        )::realtime.wal_rls;
;
    -- The claims role does not have SELECT permission to the primary key of entity;
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then;
        return next (;
            jsonb_build_object(;
                'schema', wal ->> 'schema',;
                'table', wal ->> 'table',;
                'type', action;
            ),;
            is_rls_enabled,;
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),;
            array['Error 401: Unauthorized'];
        )::realtime.wal_rls;
;
    else;
        output = jsonb_build_object(;
            'schema', wal ->> 'schema',;
            'table', wal ->> 'table',;
            'type', action,;
            'commit_timestamp', to_char(;
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),;
"                'YYYY-MM-DD""""T""""HH24:MI:SS.MS""""Z""""'";
            ),;
            'columns', (;
                select;
                    jsonb_agg(;
                        jsonb_build_object(;
                            'name', pa.attname,;
                            'type', pt.typname;
                        );
                        order by pa.attnum asc;
                    );
                from;
                    pg_attribute pa;
                    join pg_type pt;
                        on pa.atttypid = pt.oid;
                where;
                    attrelid = entity_;
                    and attnum > 0;
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT');
            );
        );
"        -- Add """"record"""" key for insert and update";
        || case;
            when action in ('INSERT', 'UPDATE') then;
                jsonb_build_object(;
                    'record',;
                    (;
                        select;
                            jsonb_object_agg(;
                                -- if unchanged toast, get column name and value from old record;
                                coalesce((c).name, (oc).name),;
                                case;
                                    when (c).name is null then (oc).value;
                                    else (c).value;
                                end;
                            );
                        from;
                            unnest(columns) c;
                            full outer join unnest(old_columns) oc;
                                on (c).name = (oc).name;
                        where;
                            coalesce((c).is_selectable, (oc).is_selectable);
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64));
                    );
                );
            else '{}'::jsonb;
        end;
"        -- Add """"old_record"""" key for update and delete";
        || case;
            when action = 'UPDATE' then;
                jsonb_build_object(;
                        'old_record',;
                        (;
                            select jsonb_object_agg((c).name, (c).value);
                            from unnest(old_columns) c;
                            where;
                                (c).is_selectable;
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64));
                        );
                    );
            when action = 'DELETE' then;
                jsonb_build_object(;
                    'old_record',;
                    (;
                        select jsonb_object_agg((c).name, (c).value);
                        from unnest(old_columns) c;
                        where;
                            (c).is_selectable;
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64));
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey;
                    );
                );
            else '{}'::jsonb;
        end;
;
        -- Create the prepared statement;
        if is_rls_enabled and action <> 'DELETE' then;
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then;
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;
;
        visible_to_subscription_ids = '{}';
;
        for subscription_id, claims in (;
                select;
                    subs.subscription_id,;
                    subs.claims;
                from;
                    unnest(subscriptions) subs;
                where;
                    subs.entity = entity_;
                    and subs.claims_role = working_role;
                    and (;
                        realtime.is_visible_through_filters(columns, subs.filters);
                        or (;
                          action = 'DELETE';
                          and realtime.is_visible_through_filters(old_columns, subs.filters);
                        );
                    );
        ) loop;
;
            if not is_rls_enabled or action = 'DELETE' then;
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else;
                -- Check if RLS allows the role to see the record;
                perform;
                    -- Trim leading and trailing quotes from working_role because set_config;
                    -- doesn't recognize the role as valid if they are included;
"                    set_config('role', trim(both '""""' from working_role::text), true),";
                    set_config('request.jwt.claims', claims::text, true);
;
                execute 'execute walrus_rls_stmt' into subscription_has_access;
;
                if subscription_has_access then;
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;
;
        perform set_config('role', null, true);
;
        return next (;
            output,;
            is_rls_enabled,;
            visible_to_subscription_ids,;
            case;
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large'];
                else '{}';
            end;
        )::realtime.wal_rls;
;
    end if;
end loop;
;
perform set_config('role', null, true);
end;
$function$;
"
realtime,broadcast_changes,topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text"",""CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)";
 RETURNS void;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
    -- Declare a variable to hold the JSONB representation of the row;
    row_data jsonb := '{}'::jsonb;
BEGIN;
    IF level = 'STATEMENT' THEN;
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly;
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN;
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE;
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION;
    WHEN OTHERS THEN;
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;
;
$function$;
"
realtime,build_prepared_statement_sql,prepared_statement_name text, entity regclass, columns realtime.wal_column[]"",""CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])";
 RETURNS text;
 LANGUAGE sql;
AS $function$;
      /*;
      Builds a sql string that, if executed, creates a prepared statement to;
      tests retrive a row from *entity* by its primary key columns.;
      Example;
"          select realtime.build_prepared_statement_sql('public.notes', '{""""id""""}'::text[], '{""""bigint""""}'::text[])";
      */;
          select;
      'prepare ' || prepared_statement_name || ' as;
          select;
              exists(;
                  select;
1;
                  from;
                      ' || entity || ';
                  where;
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || ';
              )';
          from;
              unnest(columns) pkc;
          where;
              pkc.is_pkey;
          group by;
              entity;
      $function$;
"
realtime,cast,val text, type_ regtype"",""CREATE OR REPLACE FUNCTION realtime.""""cast""""(val text, type_ regtype)";
 RETURNS jsonb;
 LANGUAGE plpgsql;
 IMMUTABLE;
AS $function$;
    declare;
      res jsonb;
    begin;
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end;
    $function$;
"
realtime,check_equality_op,op realtime.equality_op, type_ regtype, val_1 text, val_2 text"",""CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)";
 RETURNS boolean;
 LANGUAGE plpgsql;
 IMMUTABLE;
AS $function$;
      /*;
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness;
      */;
      declare;
          op_symbol text = (;
              case;
                  when op = 'eq' then '=';
                  when op = 'neq' then '!=';
                  when op = 'lt' then '<';
                  when op = 'lte' then '<=';
                  when op = 'gt' then '>';
                  when op = 'gte' then '>=';
                  when op = 'in' then '= any';
                  else 'UNKNOWN OP';
              end;
          );
          res boolean;
      begin;
          execute format(;
              'select %L::'|| type_::text || ' ' || op_symbol;
              || ' ( %L::';
              || (;
                  case;
                      when op = 'in' then type_::text || '[]';
                      else type_::text end;
              );
              || ')', val_1, val_2) into res;
          return res;
      end;
      $function$;
"
realtime,is_visible_through_filters,columns realtime.wal_column[], filters realtime.user_defined_filter[]"",""CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])";
 RETURNS boolean;
 LANGUAGE sql;
 IMMUTABLE;
AS $function$;
    /*;
    Should the record be visible (true) or filtered out (false) after *filters* are applied;
    */;
        select;
            -- Default to allowed when no filters present;
            $2 is null -- no filters. this should not happen because subscriptions has a default;
            or array_length($2, 1) is null -- array length of an empty array is null;
            or bool_and(;
                coalesce(;
                    realtime.check_equality_op(;
                        op:=f.op,;
                        type_:=coalesce(;
                            col.type_oid::regtype, -- null when wal2json version <= 2.4;
                            col.type_name::regtype;
                        ),;
                        -- cast jsonb to text;
                        val_1:=col.value #>> '{}',;
                        val_2:=f.value;
                    ),;
                    false -- if null, filter does not match;
                );
            );
        from;
            unnest(filters) f;
            join unnest(columns) col;
                on f.column_name = col.name;
    $function$;
"
realtime,list_changes,publication name, slot_name name, max_changes integer, max_record_bytes integer"",""CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)";
 RETURNS SETOF realtime.wal_rls;
 LANGUAGE sql;
 SET log_min_messages TO 'fatal';
AS $function$;
      with pub as (;
        select;
          concat_ws(;
            ',',;
            case when bool_or(pubinsert) then 'insert' else null end,;
            case when bool_or(pubupdate) then 'update' else null end,;
            case when bool_or(pubdelete) then 'delete' else null end;
          ) as w2j_actions,;
          coalesce(;
            string_agg(;
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),;
              ',';
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),;
            '';
          ) w2j_add_tables;
        from;
          pg_publication pp;
          left join pg_publication_tables ppt;
            on pp.pubname = ppt.pubname;
        where;
          pp.pubname = publication;
        group by;
          pp.pubname;
        limit 1;
      ),;
      w2j as (;
        select;
          x.*, pub.w2j_add_tables;
        from;
          pub,;
          pg_logical_slot_get_changes(;
            slot_name, null, max_changes,;
            'include-pk', 'true',;
            'include-transaction', 'false',;
            'include-timestamp', 'true',;
            'include-type-oids', 'true',;
            'format-version', '2',;
            'actions', pub.w2j_actions,;
            'add-tables', pub.w2j_add_tables;
          ) x;
      );
      select;
        xyz.wal,;
        xyz.is_rls_enabled,;
        xyz.subscription_ids,;
        xyz.errors;
      from;
        w2j,;
        realtime.apply_rls(;
          wal := w2j.data::jsonb,;
          max_record_bytes := max_record_bytes;
        ) xyz(wal, is_rls_enabled, subscription_ids, errors);
      where;
        w2j.w2j_add_tables <> '';
        and xyz.subscription_ids[1] is not null;
    $function$;
"
realtime,quote_wal2json,entity regclass,CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)";
 RETURNS text;
 LANGUAGE sql;
 IMMUTABLE STRICT;
AS $function$;
      select;
        (;
          select string_agg('' || ch,'');
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx);
          where;
"            not (x.idx = 1 and x.ch = '""""')";
            and not (;
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1);
"              and x.ch = '""""'";
            );
        );
        || '.';
        || (;
          select string_agg('' || ch,'');
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx);
          where;
"            not (x.idx = 1 and x.ch = '""""')";
            and not (;
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1);
"              and x.ch = '""""'";
            );
          );
      from;
        pg_class pc;
        join pg_namespace nsp;
          on pc.relnamespace = nsp.oid;
      where;
        pc.oid = entity;
    $function$;
"
realtime,send,payload jsonb, event text, topic text, private boolean"",""CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)";
 RETURNS void;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
  generated_id uuid;
  final_payload jsonb;
BEGIN;
  BEGIN;
    -- Generate a new UUID for the id;
    generated_id := gen_random_uuid();
;
    -- Check if payload has an 'id' key, if not, add the generated UUID;
    IF payload ? 'id' THEN;
      final_payload := payload;
    ELSE;
      final_payload := jsonb_set(payload, '{id}', to_jsonb(generated_id));
    END IF;
;
    -- Set the topic configuration;
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);
;
    -- Attempt to insert the message;
    INSERT INTO realtime.messages (id, payload, event, topic, private, extension);
    VALUES (generated_id, final_payload, event, topic, private, 'broadcast');
  EXCEPTION;
    WHEN OTHERS THEN;
      -- Capture and notify the error;
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$function$;
"
realtime,subscription_check_filters,,CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
    /*;
    Validates that the user defined filters for a subscription:;
    - refer to valid columns that the claimed role may access;
    - values are coercable to the correct column type;
    */;
    declare;
        col_names text[] = coalesce(;
                array_agg(c.column_name order by c.ordinal_position),;
                '{}'::text[];
            );
            from;
                information_schema.columns c;
            where;
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity;
                and pg_catalog.has_column_privilege(;
                    (new.claims ->> 'role'),;
                    format('%I.%I', c.table_schema, c.table_name)::regclass,;
                    c.column_name,;
                    'SELECT';
                );
        filter realtime.user_defined_filter;
        col_type regtype;
;
        in_val jsonb;
    begin;
        for filter in select * from unnest(new.filters) loop;
            -- Filtered column is valid;
            if not filter.column_name = any(col_names) then;
                raise exception 'invalid column for filter %', filter.column_name;
            end if;
;
            -- Type is sanitized and safe for string interpolation;
            col_type = (;
                select atttypid::regtype;
                from pg_catalog.pg_attribute;
                where attrelid = new.entity;
                      and attname = filter.column_name;
            );
            if col_type is null then;
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;
;
            -- Set maximum number of entries for in filter;
            if filter.op = 'in'::realtime.equality_op then;
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then;
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else;
                -- raises an exception if value is not coercable to type;
                perform realtime.cast(filter.value, col_type);
            end if;
;
        end loop;
;
        -- Apply consistent order to filters so the unique constraint on;
        -- (subscription_id, entity, filters) can't be tricked by a different filter order;
        new.filters = coalesce(;
            array_agg(f order by f.column_name, f.op, f.value),;
            '{}';
        ) from unnest(new.filters) f;
;
        return new;
    end;
    $function$;
"
realtime,to_regrole,role_name text,CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)";
 RETURNS regrole;
 LANGUAGE sql;
 IMMUTABLE;
AS $function$ select role_name::regrole $function$;
"
realtime,topic,,CREATE OR REPLACE FUNCTION realtime.topic()";
 RETURNS text;
 LANGUAGE sql;
 STABLE;
AS $function$;
select nullif(current_setting('realtime.topic', true), '')::text;
$function$;
"
storage,add_prefixes,_bucket_id text, _name text"",""CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    prefixes text[];
BEGIN;
"    prefixes := """"storage"""".""""get_prefixes""""(""""_name"""")";
;
    IF array_length(prefixes, 1) > 0 THEN;
        INSERT INTO storage.prefixes (name, bucket_id);
"        SELECT UNNEST(prefixes) as name, """"_bucket_id"""" ON CONFLICT DO NOTHING";
    END IF;
END;
$function$;
"
storage,can_insert_object,bucketid text, name text, owner uuid, metadata jsonb"",""CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)";
 RETURNS void;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
"  INSERT INTO """"storage"""".""""objects"""" (""""bucket_id"""", """"name"""", """"owner"""", """"metadata"""") VALUES (bucketid, name, owner, metadata)";
  -- hack to rollback the successful insert;
  RAISE sqlstate 'PT200' using;
  message = 'ROLLBACK',;
  detail = 'rollback successful insert';
END;
$function$;
"
storage,delete_leaf_prefixes,bucket_ids text[], names text[]"",""CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_rows_deleted integer;
BEGIN;
    LOOP;
        WITH candidates AS (;
            SELECT DISTINCT;
                t.bucket_id,;
                unnest(storage.get_prefixes(t.name)) AS name;
            FROM unnest(bucket_ids, names) AS t(bucket_id, name);
        ),;
        uniq AS (;
             SELECT;
                 bucket_id,;
                 name,;
                 storage.get_level(name) AS level;
             FROM candidates;
             WHERE name <> '';
             GROUP BY bucket_id, name;
        ),;
        leaf AS (;
             SELECT;
                 p.bucket_id,;
                 p.name,;
                 p.level;
             FROM storage.prefixes AS p;
                  JOIN uniq AS u;
                       ON u.bucket_id = p.bucket_id;
                           AND u.name = p.name;
                           AND u.level = p.level;
             WHERE NOT EXISTS (;
                 SELECT 1;
                 FROM storage.objects AS o;
                 WHERE o.bucket_id = p.bucket_id;
                   AND o.level = p.level + 1;
"                   AND o.name COLLATE """"C"""" LIKE p.name || '/%'";
             );
             AND NOT EXISTS (;
                 SELECT 1;
                 FROM storage.prefixes AS c;
                 WHERE c.bucket_id = p.bucket_id;
                   AND c.level = p.level + 1;
"                   AND c.name COLLATE """"C"""" LIKE p.name || '/%'";
             );
        );
        DELETE;
        FROM storage.prefixes AS p;
            USING leaf AS l;
        WHERE p.bucket_id = l.bucket_id;
          AND p.name = l.name;
          AND p.level = l.level;
;
        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$function$;
"
storage,delete_prefix,_bucket_id text, _name text"",""CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)";
 RETURNS boolean;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
BEGIN;
    -- Check if we can delete the prefix;
    IF EXISTS(;
"        SELECT FROM """"storage"""".""""prefixes""""";
"        WHERE """"prefixes"""".""""bucket_id"""" = """"_bucket_id""""";
"          AND level = """"storage"""".""""get_level""""(""""_name"""") + 1";
"          AND """"prefixes"""".""""name"""" COLLATE """"C"""" LIKE """"_name"""" || '/%'";
        LIMIT 1;
    );
    OR EXISTS(;
"        SELECT FROM """"storage"""".""""objects""""";
"        WHERE """"objects"""".""""bucket_id"""" = """"_bucket_id""""";
"          AND """"storage"""".""""get_level""""(""""objects"""".""""name"""") = """"storage"""".""""get_level""""(""""_name"""") + 1";
"          AND """"objects"""".""""name"""" COLLATE """"C"""" LIKE """"_name"""" || '/%'";
        LIMIT 1;
    ) THEN;
    -- There are sub-objects, skip deletion;
    RETURN false;
    ELSE;
"        DELETE FROM """"storage"""".""""prefixes""""";
"        WHERE """"prefixes"""".""""bucket_id"""" = """"_bucket_id""""";
"          AND level = """"storage"""".""""get_level""""(""""_name"""")";
"          AND """"prefixes"""".""""name"""" = """"_name""""";
        RETURN true;
    END IF;
END;
$function$;
"
storage,delete_prefix_hierarchy_trigger,,CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
    prefix text;
BEGIN;
"    prefix := """"storage"""".""""get_prefix""""(OLD.""""name"""")";
;
    IF coalesce(prefix, '') != '' THEN;
"        PERFORM """"storage"""".""""delete_prefix""""(OLD.""""bucket_id"""", prefix)";
    END IF;
;
    RETURN OLD;
END;
$function$;
"
storage,enforce_bucket_name_length,,CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
begin;
    if length(new.name) > 100 then;
"        raise exception 'bucket name """"%"""" is too long (% characters). Max is 100.', new.name, length(new.name)";
    end if;
    return new;
end;
$function$;
"
storage,extension,name text,CREATE OR REPLACE FUNCTION storage.extension(name text)";
 RETURNS text;
 LANGUAGE plpgsql;
 IMMUTABLE;
AS $function$;
DECLARE;
    _parts text[];
    _filename text;
BEGIN;
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END;
$function$;
"
storage,filename,name text,CREATE OR REPLACE FUNCTION storage.filename(name text)";
 RETURNS text;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
_parts text[];
BEGIN;
"	select string_to_array(name, '/') into _parts";
"	return _parts[array_length(_parts,1)]";
END;
$function$;
"
storage,foldername,name text,CREATE OR REPLACE FUNCTION storage.foldername(name text)";
 RETURNS text[];
 LANGUAGE plpgsql;
 IMMUTABLE;
AS $function$;
DECLARE;
    _parts text[];
BEGIN;
"    -- Split on """"/"""" to get path segments";
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment;
    RETURN _parts[1 : array_length(_parts,1) - 1];
END;
$function$;
"
storage,get_level,name text,CREATE OR REPLACE FUNCTION storage.get_level(name text)";
 RETURNS integer;
 LANGUAGE sql;
 IMMUTABLE STRICT;
AS $function$;
"SELECT array_length(string_to_array(""""name"""", '/'), 1)";
$function$;
"
storage,get_prefix,name text,CREATE OR REPLACE FUNCTION storage.get_prefix(name text)";
 RETURNS text;
 LANGUAGE sql;
 IMMUTABLE STRICT;
AS $function$;
SELECT;
"    CASE WHEN strpos(""""name"""", '/') > 0 THEN";
"             regexp_replace(""""name"""", '[\/]{1}[^\/]+\/?$', '')";
         ELSE;
             '';
        END;
$function$;
"
storage,get_prefixes,name text,CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)";
 RETURNS text[];
 LANGUAGE plpgsql;
 IMMUTABLE STRICT;
AS $function$;
DECLARE;
    parts text[];
    prefixes text[];
    prefix text;
BEGIN;
    -- Split the name into parts by '/';
"    parts := string_to_array(""""name"""", '/')";
    prefixes := '{}';
;
    -- Construct the prefixes, stopping one level below the last part;
    FOR i IN 1..array_length(parts, 1) - 1 LOOP;
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;
;
    RETURN prefixes;
END;
$function$;
"
storage,get_size_by_bucket,,CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()";
 RETURNS TABLE(size bigint, bucket_id text);
 LANGUAGE plpgsql;
 STABLE;
AS $function$;
BEGIN;
    return query;
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id;
"        from """"storage"""".objects as obj";
        group by obj.bucket_id;
END;
$function$;
"
storage,list_multipart_uploads_with_delimiter,bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text"",""CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)";
 RETURNS TABLE(key text, id text, created_at timestamp with time zone);
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    RETURN QUERY EXECUTE;
"        'SELECT DISTINCT ON(key COLLATE """"C"""") * from (";
            SELECT;
                CASE;
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN;
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)));
                    ELSE;
                        key;
                END AS key, id, created_at;
            FROM;
                storage.s3_multipart_uploads;
            WHERE;
                bucket_id = $5 AND;
                key ILIKE $1 || ''%'' AND;
                CASE;
                    WHEN $4 != '''' AND $6 = '''' THEN;
                        CASE;
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN;
"                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE """"C"""" > $4";
                            ELSE;
"                                key COLLATE """"C"""" > $4";
                            END;
                    ELSE;
                        true;
                END AND;
                CASE;
                    WHEN $6 != '''' THEN;
"                        id COLLATE """"C"""" > $6";
                    ELSE;
                        true;
                    END;
            ORDER BY;
"                key COLLATE """"C"""" ASC, created_at ASC) as e order by key COLLATE """"C"""" LIMIT $3'";
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$function$;
"
storage,list_objects_with_delimiter,bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text"",""CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)";
 RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone);
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    RETURN QUERY EXECUTE;
"        'SELECT DISTINCT ON(name COLLATE """"C"""") * from (";
            SELECT;
                CASE;
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN;
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)));
                    ELSE;
                        name;
                END AS name, id, metadata, updated_at;
            FROM;
                storage.objects;
            WHERE;
                bucket_id = $5 AND;
                name ILIKE $1 || ''%'' AND;
                CASE;
                    WHEN $6 != '''' THEN;
"                    name COLLATE """"C"""" > $6";
                ELSE true END;
                AND CASE;
                    WHEN $4 != '''' THEN;
                        CASE;
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN;
"                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE """"C"""" > $4";
                            ELSE;
"                                name COLLATE """"C"""" > $4";
                            END;
                    ELSE;
                        true;
                END;
            ORDER BY;
"                name COLLATE """"C"""" ASC) as e order by name COLLATE """"C"""" LIMIT $3'";
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$function$;
"
storage,lock_top_prefixes,bucket_ids text[], names text[]"",""CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_bucket text;
    v_top text;
BEGIN;
    FOR v_bucket, v_top IN;
        SELECT DISTINCT t.bucket_id,;
            split_part(t.name, '/', 1) AS top;
        FROM unnest(bucket_ids, names) AS t(bucket_id, name);
        WHERE t.name <> '';
        ORDER BY 1, 2;
        LOOP;
            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));
        END LOOP;
END;
$function$;
"
storage,objects_delete_cleanup,,CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_bucket_ids text[];
    v_names      text[];
BEGIN;
    IF current_setting('storage.gc.prefixes', true) = '1' THEN;
        RETURN NULL;
    END IF;
;
    PERFORM set_config('storage.gc.prefixes', '1', true);
;
    SELECT COALESCE(array_agg(d.bucket_id), '{}'),;
           COALESCE(array_agg(d.name), '{}');
    INTO v_bucket_ids, v_names;
    FROM deleted AS d;
    WHERE d.name <> '';
;
    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);
;
    RETURN NULL;
END;
$function$;
"
storage,objects_insert_prefix_trigger,,CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
"    PERFORM """"storage"""".""""add_prefixes""""(NEW.""""bucket_id"""", NEW.""""name"""")";
"    NEW.level := """"storage"""".""""get_level""""(NEW.""""name"""")";
;
    RETURN NEW;
END;
$function$;
"
storage,objects_update_cleanup,,CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    -- NEW - OLD (destinations to create prefixes for);
    v_add_bucket_ids text[];
    v_add_names      text[];
;
    -- OLD - NEW (sources to prune);
    v_src_bucket_ids text[];
    v_src_names      text[];
BEGIN;
    IF TG_OP <> 'UPDATE' THEN;
        RETURN NULL;
    END IF;
;
    -- 1) Compute NEW−OLD (added paths) and OLD−NEW (moved-away paths);
    WITH added AS (;
        SELECT n.bucket_id, n.name;
        FROM new_rows n;
        WHERE n.name <> '' AND position('/' in n.name) > 0;
        EXCEPT;
        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> '';
    ),;
    moved AS (;
         SELECT o.bucket_id, o.name;
         FROM old_rows o;
         WHERE o.name <> '';
         EXCEPT;
         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> '';
    );
    SELECT;
        -- arrays for ADDED (dest) in stable order;
        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),;
        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),;
        -- arrays for MOVED (src) in stable order;
        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),;
        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' );
    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;
;
    -- Nothing to do?;
    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN;
        RETURN NULL;
    END IF;
;
    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks;
    DECLARE;
        v_all_bucket_ids text[];
        v_all_names text[];
    BEGIN;
        -- Combine source and destination arrays for consistent lock ordering;
        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');
        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');
;
        -- Single lock call ensures consistent global ordering across all transactions;
        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN;
            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);
        END IF;
    END;
;
    -- 3) Create destination prefixes (NEW−OLD) BEFORE pruning sources;
    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN;
        WITH candidates AS (;
            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name;
            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name);
            WHERE name <> '';
        );
        INSERT INTO storage.prefixes (bucket_id, name);
        SELECT c.bucket_id, c.name;
        FROM candidates c;
        ON CONFLICT DO NOTHING;
    END IF;
;
    -- 4) Prune source prefixes bottom-up for OLD−NEW;
    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN;
        -- re-entrancy guard so DELETE on prefixes won't recurse;
        IF current_setting('storage.gc.prefixes', true) <> '1' THEN;
            PERFORM set_config('storage.gc.prefixes', '1', true);
        END IF;
;
        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);
    END IF;
;
    RETURN NULL;
END;
$function$;
"
storage,objects_update_level_trigger,,CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    -- Ensure this is an update operation and the name has changed;
"    IF TG_OP = 'UPDATE' AND (NEW.""""name"""" <> OLD.""""name"""" OR NEW.""""bucket_id"""" <> OLD.""""bucket_id"""") THEN";
        -- Set the new level;
"        NEW.""""level"""" := """"storage"""".""""get_level""""(NEW.""""name"""")";
    END IF;
    RETURN NEW;
END;
$function$;
"
storage,objects_update_prefix_trigger,,CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
DECLARE;
    old_prefixes TEXT[];
BEGIN;
    -- Ensure this is an update operation and the name has changed;
"    IF TG_OP = 'UPDATE' AND (NEW.""""name"""" <> OLD.""""name"""" OR NEW.""""bucket_id"""" <> OLD.""""bucket_id"""") THEN";
        -- Retrieve old prefixes;
"        old_prefixes := """"storage"""".""""get_prefixes""""(OLD.""""name"""")";
;
        -- Remove old prefixes that are only used by this object;
        WITH all_prefixes as (;
            SELECT unnest(old_prefixes) as prefix;
        ),;
        can_delete_prefixes as (;
             SELECT prefix;
             FROM all_prefixes;
             WHERE NOT EXISTS (;
"                 SELECT 1 FROM """"storage"""".""""objects""""";
"                 WHERE """"bucket_id"""" = OLD.""""bucket_id""""";
"                   AND """"name"""" <> OLD.""""name""""";
"                   AND """"name"""" LIKE (prefix || '%')";
             );
         );
"        DELETE FROM """"storage"""".""""prefixes"""" WHERE name IN (SELECT prefix FROM can_delete_prefixes)";
;
        -- Add new prefixes;
"        PERFORM """"storage"""".""""add_prefixes""""(NEW.""""bucket_id"""", NEW.""""name"""")";
    END IF;
    -- Set the new level;
"    NEW.""""level"""" := """"storage"""".""""get_level""""(NEW.""""name"""")";
;
    RETURN NEW;
END;
$function$;
"
storage,operation,,CREATE OR REPLACE FUNCTION storage.operation()";
 RETURNS text;
 LANGUAGE plpgsql;
 STABLE;
AS $function$;
BEGIN;
    RETURN current_setting('storage.operation', true);
END;
$function$;
"
storage,prefixes_delete_cleanup,,CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()";
 RETURNS trigger;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
AS $function$;
DECLARE;
    v_bucket_ids text[];
    v_names      text[];
BEGIN;
    IF current_setting('storage.gc.prefixes', true) = '1' THEN;
        RETURN NULL;
    END IF;
;
    PERFORM set_config('storage.gc.prefixes', '1', true);
;
    SELECT COALESCE(array_agg(d.bucket_id), '{}'),;
           COALESCE(array_agg(d.name), '{}');
    INTO v_bucket_ids, v_names;
    FROM deleted AS d;
    WHERE d.name <> '';
;
    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);
;
    RETURN NULL;
END;
$function$;
"
storage,prefixes_insert_trigger,,CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
"    PERFORM """"storage"""".""""add_prefixes""""(NEW.""""bucket_id"""", NEW.""""name"""")";
    RETURN NEW;
END;
$function$;
"
storage,search,prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text"",""CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)";
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb);
 LANGUAGE plpgsql;
AS $function$;
declare;
    can_bypass_rls BOOLEAN;
begin;
    SELECT rolbypassrls;
    INTO can_bypass_rls;
    FROM pg_roles;
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);
;
    IF can_bypass_rls THEN;
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE;
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$function$;
"
storage,search_legacy_v1,prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text"",""CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)";
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb);
 LANGUAGE plpgsql;
 STABLE;
AS $function$;
declare;
    v_order_by text;
    v_sort_order text;
begin;
    case;
        when sortcolumn = 'name' then;
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then;
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then;
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then;
            v_order_by = 'last_accessed_at';
        else;
            v_order_by = 'name';
        end case;
;
    case;
        when sortorder = 'asc' then;
            v_sort_order = 'asc';
        when sortorder = 'desc' then;
            v_sort_order = 'desc';
        else;
            v_sort_order = 'asc';
        end case;
;
    v_order_by = v_order_by || ' ' || v_sort_order;
;
    return query execute;
        'with folders as (;
           select path_tokens[$1] as folder;
           from storage.objects;
             where objects.name ilike $2 || $3 || ''%'';
               and bucket_id = $4;
               and array_length(objects.path_tokens, 1) <> $1;
           group by folder;
           order by folder ' || v_sort_order || ';
     );
"     (select folder as """"name"""",";
            null as id,;
            null as updated_at,;
            null as created_at,;
            null as last_accessed_at,;
            null as metadata from folders);
     union all;
"     (select path_tokens[$1] as """"name"""",";
            id,;
            updated_at,;
            created_at,;
            last_accessed_at,;
            metadata;
     from storage.objects;
     where objects.name ilike $2 || $3 || ''%'';
       and bucket_id = $4;
       and array_length(objects.path_tokens, 1) = $1;
     order by ' || v_order_by || ');
     limit $5;
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$;
"
storage,search_v1_optimised,prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text"",""CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)";
 RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb);
 LANGUAGE plpgsql;
 STABLE;
AS $function$;
declare;
    v_order_by text;
    v_sort_order text;
begin;
    case;
        when sortcolumn = 'name' then;
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then;
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then;
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then;
            v_order_by = 'last_accessed_at';
        else;
            v_order_by = 'name';
        end case;
;
    case;
        when sortorder = 'asc' then;
            v_sort_order = 'asc';
        when sortorder = 'desc' then;
            v_sort_order = 'desc';
        else;
            v_sort_order = 'asc';
        end case;
;
    v_order_by = v_order_by || ' ' || v_sort_order;
;
    return query execute;
        'with folders as (;
           select (string_to_array(name, ''/''))[level] as name;
           from storage.prefixes;
             where lower(prefixes.name) like lower($2 || $3) || ''%'';
               and bucket_id = $4;
               and level = $1;
           order by name ' || v_sort_order || ';
     );
     (select name,;
            null as id,;
            null as updated_at,;
            null as created_at,;
            null as last_accessed_at,;
            null as metadata from folders);
     union all;
"     (select path_tokens[level] as """"name"""",";
            id,;
            updated_at,;
            created_at,;
            last_accessed_at,;
            metadata;
     from storage.objects;
     where lower(objects.name) like lower($2 || $3) || ''%'';
       and bucket_id = $4;
       and level = $1;
     order by ' || v_order_by || ');
     limit $5;
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$function$;
"
storage,search_v2,prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text"",""CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)";
 RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb);
 LANGUAGE plpgsql;
 STABLE;
AS $function$;
DECLARE;
    sort_col text;
    sort_ord text;
    cursor_op text;
    cursor_expr text;
    sort_expr text;
BEGIN;
    -- Validate sort_order;
    sort_ord := lower(sort_order);
    IF sort_ord NOT IN ('asc', 'desc') THEN;
        sort_ord := 'asc';
    END IF;
;
    -- Determine cursor comparison operator;
    IF sort_ord = 'asc' THEN;
        cursor_op := '>';
    ELSE;
        cursor_op := '<';
    END IF;
    ;
    sort_col := lower(sort_column);
    -- Validate sort column  ;
    IF sort_col IN ('updated_at', 'created_at') THEN;
        cursor_expr := format(;
"            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE """"C"""") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',";
            sort_col, cursor_op;
        );
        sort_expr := format(;
"            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE """"C"""" %s',";
            sort_col, sort_ord, sort_ord;
        );
    ELSE;
"        cursor_expr := format('($5 = '''' OR name COLLATE """"C"""" %s $5)', cursor_op)";
"        sort_expr := format('name COLLATE """"C"""" %s', sort_ord)";
    END IF;
;
    RETURN QUERY EXECUTE format(;
        $sql$;
        SELECT * FROM (;
            (;
                SELECT;
                    split_part(name, '/', $4) AS key,;
                    name,;
                    NULL::uuid AS id,;
                    updated_at,;
                    created_at,;
                    NULL::timestamptz AS last_accessed_at,;
                    NULL::jsonb AS metadata;
                FROM storage.prefixes;
"                WHERE name COLLATE """"C"""" LIKE $1 || '%%'";
                    AND bucket_id = $2;
                    AND level = $4;
                    AND %s;
                ORDER BY %s;
                LIMIT $3;
            );
            UNION ALL;
            (;
                SELECT;
                    split_part(name, '/', $4) AS key,;
                    name,;
                    id,;
                    updated_at,;
                    created_at,;
                    last_accessed_at,;
                    metadata;
                FROM storage.objects;
"                WHERE name COLLATE """"C"""" LIKE $1 || '%%'";
                    AND bucket_id = $2;
                    AND level = $4;
                    AND %s;
                ORDER BY %s;
                LIMIT $3;
            );
        ) obj;
        ORDER BY %s;
        LIMIT $3;
        $sql$,;
        cursor_expr,    -- prefixes WHERE;
        sort_expr,      -- prefixes ORDER BY;
        cursor_expr,    -- objects WHERE;
        sort_expr,      -- objects ORDER BY;
        sort_expr       -- final ORDER BY;
    );
    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;
END;
$function$;
"
storage,update_updated_at_column,,CREATE OR REPLACE FUNCTION storage.update_updated_at_column()";
 RETURNS trigger;
 LANGUAGE plpgsql;
AS $function$;
BEGIN;
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$;
"
vault,_crypto_aead_det_decrypt,message bytea, additional bytea, key_id bigint, context bytea, nonce bytea"",""CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE;
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$;
"
vault,_crypto_aead_det_encrypt,message bytea, additional bytea, key_id bigint, context bytea, nonce bytea"",""CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE;
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$;
"
vault,_crypto_aead_det_noncegen,,CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()";
 RETURNS bytea;
 LANGUAGE c;
 IMMUTABLE;
AS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$;
"
vault,create_secret,new_secret text, new_name text, new_description text, new_key_id uuid"",""CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)";
 RETURNS uuid;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO '';
AS $function$;
DECLARE;
  rec record;
BEGIN;
  INSERT INTO vault.secrets (secret, name, description);
  VALUES (;
    new_secret,;
    new_name,;
    new_description;
  );
  RETURNING * INTO rec;
  UPDATE vault.secrets s;
  SET secret = encode(vault._crypto_aead_det_encrypt(;
    message := convert_to(rec.secret, 'utf8'),;
    additional := convert_to(s.id::text, 'utf8'),;
    key_id := 0,;
    context := 'pgsodium'::bytea,;
    nonce := rec.nonce;
  ), 'base64');
  WHERE id = rec.id;
  RETURN rec.id;
END;
$function$;
"
vault,update_secret,secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid"",""CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)";
 RETURNS void;
 LANGUAGE plpgsql;
 SECURITY DEFINER;
 SET search_path TO '';
AS $function$;
DECLARE;
  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);
BEGIN;
  UPDATE vault.secrets s;
  SET;
    secret = CASE WHEN new_secret IS NULL THEN s.secret;
                  ELSE encode(vault._crypto_aead_det_encrypt(;
                    message := convert_to(new_secret, 'utf8'),;
                    additional := convert_to(s.id::text, 'utf8'),;
                    key_id := 0,;
                    context := 'pgsodium'::bytea,;
                    nonce := s.nonce;
                  ), 'base64') END,;
    name = coalesce(new_name, s.name),;
    description = coalesce(new_description, s.description),;
    updated_at = now();
  WHERE s.id = secret_id;
END;
$function$;
